#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[{"name":"spiral"}]}}

#!markdown

# spiral

#!spiral

//// test
//// test_force

open testing

#!spiral

open file_system_operators
open rust.rust_operators
open rust
open sm'_operators
open parsing

#!markdown

## fable

#!markdown

### fable_target

#!spiral

union fable_target =
    | Rust
    | TypeScript
    | Python

#!markdown

### fable_runtime

#!spiral

union fable_runtime =
    | Wasm : string
    | Contract : string

#!markdown

### execute_dotnet_fable

#!spiral

let execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir runtime } =
    open runtime
    execution_options fun x => { x with
        command =
            inl platform =
                if platform.is_windows ()
                then "_WINDOWS"
                else "_LINUX"
            inl platform : string = $'$" --define {!platform}"'
            inl runtime =
                match runtime with
                | Some (runtime : fable_runtime) =>
                    inl runtime = runtime |> reflection.union_to_string |> sm'.to_upper
                    $'$" --define {!runtime}"'
                | None => ""
            $'$"dotnet fable \\\"{!fsproj_path}\\\" --optimize --lang {!extension} --extension .{!extension} --outDir \\\"{!package_dir}\\\"{!platform}{!runtime}"'
        working_directory = workspace_root_external |> resultm.box |> resultm.ok'
    }
    |> execute_retry 3u8

#!markdown

### get_package_dir

#!spiral

let get_package_dir { workspace_root target name hash } =
    inl dir = workspace_root </> "target/spiral" </> name
    match hash, (target : option fable_target) with
    | Some hash, Some target => dir </> "packages" </> (target |> reflection.union_to_string) </> hash
    | _ => dir

#!markdown

### persist_code_project

#!spiral

let persist_code_project { workspace_root package_dir packages modules name code } =
    package_dir |> file_system.create_dir |> ignore

    inl fs_path = package_dir </> $'$"{!name}.fs"' |> file_system.normalize_path
    code |> file_system.write_all_text_exists fs_path

    inl modules_code =
        modules
        |> listm.map fun path =>
            inl path = workspace_root </> path
            $'$"<Compile Include=\\\"{!path}\\\" />"' : string
        |> listm'.box
        |> seq.of_list'
        |> sm'.concat "\\n        "

    inl packages_code =
        packages
        |> listm.map fun (package : string), (version : string) =>
            $'$"<PackageReference Include=\\\"{!package}\\\" Version=\\\"{!version}\\\" />"' : string
        |> listm'.box
        |> seq.of_list'
        |> sm'.concat "\\n        "

    inl fsproj_path = package_dir </> $'$"{!name}.fsproj"' |> file_system.normalize_path
    inl fsproj_code : string =
        $'$"<Project Sdk=\\\"Microsoft.NET.Sdk\\\">"'
        ++\# $'$"<PropertyGroup>"'
        ++\# $'$"    <TargetFramework>net9.0</TargetFramework>"'
        ++\# $'$"    <LangVersion>preview</LangVersion>"'
        ++\# $'$"    <RollForward>Major</RollForward>"'
        ++\# $'$"    <TargetLatestRuntimePatch>true</TargetLatestRuntimePatch>"'
        ++\# $'$"    <PublishAot>false</PublishAot>"'
        ++\# $'$"    <PublishTrimmed>false</PublishTrimmed>"'
        ++\# $'$"    <PublishSingleFile>true</PublishSingleFile>"'
        ++\# $'$"    <SelfContained>true</SelfContained>"'
        ++\# $'$"    <Version>0.0.1-alpha.1</Version>"'
        ++\# $'$"    <OutputType>Exe</OutputType>"'
        ++\# $'$"    <ServerGarbageCollection>true</ServerGarbageCollection>"'
        ++\# $'$"    <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>"'
        ++\# $'$"</PropertyGroup>"'

        ++\# $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'FreeBSD\'))\\\">"'
        ++\# $'$"    <DefineConstants>_FREEBSD</DefineConstants>"'
        ++\# $'$"</PropertyGroup>"'

        ++\# $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'Linux\'))\\\">"'
        ++\# $'$"    <DefineConstants>_LINUX</DefineConstants>"'
        ++\# $'$"</PropertyGroup>"'

        ++\# $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'OSX\'))\\\">"'
        ++\# $'$"    <DefineConstants>_OSX</DefineConstants>"'
        ++\# $'$"</PropertyGroup>"'

        ++\# $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'Windows\'))\\\">"'
        ++\# $'$"    <DefineConstants>_WINDOWS</DefineConstants>"'
        ++\# $'$"</PropertyGroup>"'

        ++\# $'$"<ItemGroup>"'
        ++\# $'$"    {!modules_code}"'
        ++\# $'$"    <Compile Include=\\\"{!fs_path}\\\" />"'
        ++\# $'$"</ItemGroup>"'

        ++\# $'$"<ItemGroup>"'
        ++\# $'$"    {!packages_code}"'
        ++\# $'$"</ItemGroup>"'

        ++\# $'$"</Project>"'

    fsproj_code |> file_system.write_all_text_exists fsproj_path

    fsproj_path

#!markdown

### publish_project

#!spiral

inl publish_project runtime' output_dir path =
    inl full_path = path |> file_system.get_full_path
    inl file_dir = full_path |> file_system.directory_get_parent |> optionm'.default_value' ""
    inl extension = full_path |> file_system.get_extension

    trace Debug
        fun () => "publish_project"
        fun () => { full_path }

    match extension with
    | "fsproj" => ()
    | _ => failwith $'$"app.publish_project / Invalid project file / extension: {!extension}"'

    inl runtimes =
        runtime'
        |> optionm.map listm.singleton
        |> optionm'.default_value [ "linux-x64"; "win-x64" ]

    inl output_dir = output_dir |> optionm'.default_value "dist"

    runtimes
    |> listm.map fun runtime' =>
        runtime.execution_options fun x => { x with
            command = $'$@@"dotnet publish \"\"{!path}\"\" --configuration Release --output \"\"{!output_dir}\"\" --runtime {!runtime'}"'
            working_directory = file_dir |> Some |> optionm'.box
        }
        |> runtime.execute_with_options
        |> fst
    |> listm'.sum

#!markdown

### publish_code

#!spiral

inl publish_code { workspace_root runtime packages modules output_dir name code } =
    inl package_dir = get_package_dir { workspace_root name target = None; hash = None }
    inl fsproj_path = persist_code_project { workspace_root package_dir packages modules name code }
    inl exit_code = fsproj_path |> publish_project runtime output_dir
    if exit_code <>. 0 then
        trace Critical
            fun () => "publish_code"
            fun () => {
                code = code |> sm'.ellipsis_end 400
                fsproj_text = fsproj_path |> file_system.read_all_text
            }
    exit_code

#!spiral

//// test
///! rust -d encoding_rs encoding_rs_io regex

publish_code {
    workspace_root = file_system.get_workspace_root ()
    runtime = None
    packages = []
    modules = []
    output_dir = None
    name = "test1"
    code = "1 + 1 |> ignore"
}
|> _assert_eq 0

#!spiral

//// test
///! rust -d encoding_rs encoding_rs_io regex

publish_code {
    workspace_root = file_system.get_workspace_root ()
    runtime = None
    packages = []
    modules = []
    output_dir = None
    name = "test2"
    code = "1 + a |> ignore"
}
|> _assert_eq 2

#!markdown

### read_file

#!spiral

inl read_file path =
    inl code =
        path
        |> file_system.read_all_text
        |> sm'.replace_regex $'@@"(?P<a> *)(?P<b>let\\s+main\\s+.*?\\s*=)"' "$a[<EntryPoint>]\n$a$b"
    inl code_trim = code |> sm'.trim_end []
    if code_trim |> sm'.ends_with "\\n()"
    then code_trim |> sm'.slice 0i64 ((code_trim |> sm'.length) - 3)
    else code

#!markdown

### persist_file

#!spiral

inl persist_file { workspace_root package_dir packages modules path } =
    inl full_path = path |> file_system.get_full_path
    inl name = full_path |> file_system.get_file_name_without_extension
    inl code = full_path |> read_file
    persist_code_project { workspace_root package_dir packages modules name code }

#!markdown

### publish_file

#!spiral

inl publish_file { workspace_root runtime packages modules path } =
    inl full_path = path |> file_system.get_full_path
    inl dir = full_path |> file_system.directory_get_parent |> optionm'.default_value' ""
    publish_code {
        workspace_root
        runtime
        packages
        modules
        output_dir = dir </> "dist" |> Some
        name = full_path |> file_system.get_file_name_without_extension
        code = full_path |> read_file
    }

#!markdown

## rust

#!markdown

### get_workspace_cargo_toml_content

#!spiral

inl get_workspace_cargo_toml_content { workspace_root } : string =
    inl workspace_root = workspace_root |> file_system.normalize_path
    $'$"cargo-features = [\\\"profile-rustflags\\\"]"'
    ++\# $'$""'
    ++\# $'$"[workspace]"'
    ++\# $'$"resolver = \\\"2\\\""'
    ++\# $'$"members = [\\\"packages/Rust/*\\\"]"'
    ++\# $'$""'
    ++\# $'$"[workspace.dependencies.fable_library_rust]"'
    ++\# $'$"path = \\\"{!workspace_root}/lib/rust/fable/fable_modules/fable-library-rust\\\""'
    ++\# $'$"default-features = false"'
    ++\# $'$"features = []"'
    ++\# $'$""'
    ++\# $'$"[workspace.dependencies]"'
    ++\# $'$"inline_colorization = \\\"~0.1\\\""'
    ++\# $'$""'
    ++\# $'$"[profile.dev]"'
    ++\# $'$"codegen-units = 256"'
    ++\# $'$"opt-level = 0"'
    ++\# $'$"lto = false"'
    ++\# $'$"debug = 1"'
    ++\# $'$"panic = \\\"unwind\\\""'
    ++\# $'$"rustflags = [\\\"-C\\\", \\\"link-arg=-s\\\"]"'
    ++\# $'$"strip = \\\"debuginfo\\\""'
    ++\# $'$"rpath = true"'
    ++\# $'$""'
    ++\# $'$"[profile.release]"'
    ++\# $'$"codegen-units = 1"'
    ++\# $'$"opt-level = \\\"z\\\""'
    ++\# $'$"lto = true"'
    ++\# $'$"debug = false"'
    ++\# $'$"panic = \\\"abort\\\""'
    ++\# $'$"overflow-checks = true"'
    ++\# $'$"rustflags = [\\\"-C\\\", \\\"link-arg=-s\\\"]"'

#!markdown

### get_cargo_toml_content

#!spiral

inl get_cargo_toml_content { hash runtime deps static_do_bindings } : string =
    $'$"cargo-features = [\\\"edition2024\\\"]"'
    ++\# $'$""'
    ++\# $'$"[package]"'
    ++\# $'$"name = \\\"spiral_{!hash}\\\""'
    ++\# $'$"version = \\\"0.0.1\\\""'
    ++\# $'$"edition = \\\"2024\\\""'
    ++\# $'$""'
    ++\# $'$"[dependencies]"'
    ++\# (
        if runtime <>. None
        then $'$"fable_library_rust = {{ workspace = true }}"'
        else
            $'$"fable_library_rust = {{"'
            +. $'$" workspace = true,"'
            +. $'$" features = ["'
            +. (
                if static_do_bindings
                then $'$"\\\"static_do_bindings\\\", \\\"datetime\\\", \\\"guid\\\", \\\"threaded\\\""'
                else $'$"\\\"datetime\\\", \\\"guid\\\", \\\"threaded\\\""'
            )
            +. $'$"]"'
            +. $'$"}}"'
    )
    ++\# $'$"inline_colorization = {{ workspace = true }}"'
    ++\# $'$"{!deps}"'
    ++\# $'$""'
    ++\# (
        if runtime = None then
            $'$"[[bin]]"'
            ++\# $'$"name = \\\"spiral_{!hash}\\\""'
        else
            $'$"[lib]"'
            ++\# $'$"crate-type = [\\\"cdylib\\\"]"'
    )
    ++\# $'$"path = \\\"spiral.rs\\\""'

#!markdown

### get_empty_cargo_toml_content

#!spiral

inl get_empty_cargo_toml_content () =
    inl guid = date_time.now () |> date_time.new_guid_from_date_time |> sm'.obj_to_string
    $'$"[package]"'
    ++\# $'$"name = \\\"spiral_{!guid}\\\""'
    ++\# $'$"version = \\\"0.0.1\\\""'
    ++\# $'$"edition = \\\"2021\\\""'
    ++\# $'$""'
    ++\# $'$"[[bin]]"'
    ++\# $'$"name = \\\"spiral_{!guid}\\\""'
    ++\# $'$"path = \\\"spiral.rs\\\""'

#!markdown

### process_rust

#!spiral

inl process_rust { fs_path deps trace_level runtime cleanup } =
    open runtime

    inl extension = "rs"
    inl code = fs_path |> file_system.read_all_text

    inl hash = { extension code runtime } |> sm'.format |> crypto.hash_text

    inl workspace_name = "spiral"

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir =
        get_package_dir { workspace_root name = workspace_name; target = Some Rust; hash = hash |> Some }

    inl fsproj_path =
        persist_code_project {
            workspace_root
            package_dir
            packages = [ "Fable.Core", "4.3.0" ]
            modules = []
            name = workspace_name
            code
        }

    inl workspace_dir = package_dir </> "../../.."
    inl workspace_cargo_toml_path = workspace_dir </> "Cargo.toml"

    if workspace_cargo_toml_path |> file_system.file_exists |> not
    then get_empty_cargo_toml_content () |> file_system.write_all_text workspace_cargo_toml_path

    inl cargo_toml_path = package_dir </> "Cargo.toml"

    if cargo_toml_path |> file_system.file_exists |> not
    then get_empty_cargo_toml_content () |> file_system.write_all_text cargo_toml_path

    inl lib_link_target_path = workspace_root </> "lib/rust/fable/fable_modules/fable-library-rust"
    inl lib_link_path = package_dir </> "fable_modules/fable-library-rust"

    lib_link_path |> file_system.link_directory lib_link_target_path

    inl exit_code, dotnet_fable_result =
        execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir runtime }

    inl result' = {
        extension = Some extension
        code = None
        code_path = None
        output = None
    }

    if exit_code <>. 0 then
        trace Critical
            fun () => "spiral.process_rust / dotnet fable error"
            fun () => { exit_code dotnet_fable_result }
        { result' with
            output = Some dotnet_fable_result
        }
    else
        inl deps =
            inl deps =
                if runtime = None
                then deps
                else
                    // TODO: simplify
                    inl has_near_sdk =
                        deps
                        |> am'.vec_filter (sm'.from_std_string >> sm'.contains "near-sdk")
                        |> am'.vec_len
                        |> convert.i32
                        |> fun (n : int) => n > 0
                    // TODO: simplify with ++
                    if has_near_sdk
                    then deps
                    else deps |> am'.vec_extend (;[ "near-sdk" |> sm'.to_std_string ] |> am'.to_vec)
                    |> am'.vec_extend (;[ "indexmap=\"=2.11.4\"" |> sm'.to_std_string ] |> am'.to_vec)
            deps
            |> am'.vec_map fun dep =>
                inl dep = dep |> sm'.from_std_string
                if dep |> sm'.contains "="
                then dep
                elif dep |> sm'.ends_with "]"
                then dep |> sm'.replace "[" $'$"={{version=\'*\',features=["' |> fun x => $'$"{!x}}}"'
                else $'$"{!dep}=\'*\'"'
            |> am'.from_vec
            |> fun x => x : _ i32 _
            |> seq.of_array'
            |> sm'.concat "\n"

        inl new_code_path = package_dir </> $'$"{!workspace_name}.{!extension}"'
        inl new_code = new_code_path |> file_system.read_all_text

        inl on_startup_text = "on_startup!" ++# (join "(")
        inl method0_fn_text = " method0" ++# (join "(")
        inl static_do_bindings =
            (new_code |> sm'.contains on_startup_text)
            && (new_code |> sm'.contains method0_fn_text |> not)
        inl cargo_toml_content =
            get_cargo_toml_content { hash runtime deps static_do_bindings }
        inl workspace_cargo_toml_content = get_workspace_cargo_toml_content { workspace_root }

        cargo_toml_content |> file_system.write_all_text_exists cargo_toml_path
        workspace_cargo_toml_content |> file_system.write_all_text_exists workspace_cargo_toml_path

        inl range_rs_path = lib_link_path </> "src/Range.rs"
        if range_rs_path |> file_system.file_exists then
            inl text = range_rs_path |> file_system.read_all_text
            text
            |> sm'.replace "use crate::String_::fromCharCode;" "use crate::String_::fromChar;"
            |> sm'.replace "fromCharCode(c)" "std::char::from_u32(c).unwrap()"
            |> file_system.write_all_text_exists range_rs_path

        inl exit_code, cargo_fmt_result =
            fun () =>
                inl exit_code, result =
                    execution_options fun x => { x with
                        command = $'$"cargo fmt --manifest-path \\\"{!cargo_toml_path}\\\" --"'
                        working_directory = workspace_root_external |> resultm.box |> resultm.ok'
                    }
                    |> execute_with_options

                inl return () =
                    if exit_code = 0
                    then Ok (exit_code, result)
                    else Error (exit_code, result)

                if result |> sm'.contains "failed to load manifest for workspace member" |> not
                then return ()
                else
                    inl missing_toml_path =
                        "failed to read `(?<a>.*?Cargo.toml)`"
                        |> sm'.new_regex
                        |> resultm.unwrap'
                        |> sm'.regex_captures result
                        |> am'.from_vec
                        |> fun x => x : _ i32 _
                        |> am'.try_item 0
                        |> optionm.map (mapm.get "a" >> optionm'.unbox)
                        |> optionm'.flatten
                    match missing_toml_path with
                    | None => Error (exit_code, result)
                    | Some missing_toml_path =>
                        if missing_toml_path |> file_system.file_exists |> not then
                            missing_toml_path
                            |> file_system.directory_get_parent
                            |> optionm'.default_value' ""
                            |> file_system.create_dir
                            |> ignore
                            get_empty_cargo_toml_content ()
                            |> file_system.write_all_text missing_toml_path
                        return ()
            |> retry_fn' 3u8

        if exit_code <>. 0 then
            trace Critical
                fun () => "spiral.process_rust / cargo fmt error"
                fun () => { exit_code cargo_fmt_result }

        inl new_code = new_code_path |> file_system.read_all_text

        inl main_code_header =
            "pub fn main() -> Result<(), String> " ++# (join "{")

        inl main_code : string =
            if runtime = None
            then ""
            else
                $'$"\#[near_sdk::near_bindgen]"'
                ++\# $'$"\#[derive(near_sdk::PanicOnDefault)]"'
                ++\# $'$"pub struct MainState {{"'
                ++\# $'$"}}"'
                ++\# $'$""'
                ++\# $'$"\#[near_sdk::near_bindgen]"'
                ++\# $'$"impl MainState {{"'
                ++\# $'$"    pub fn state_main() {{"'
                ++\# $'$"        Spiral::method0();"'
                ++\# $'$"    }}"'
                ++\# $'$"}}"'
            ++\# (
                if runtime = None && (new_code |> sm'.contains (on_startup_text ++# "Spiral::method0()"))
                then $'$"{!main_code_header} Ok(Spiral::method0()) }}"'
                else $'$"{!main_code_header} Ok(()) }}"'
            )

        inl cached = new_code |> sm'.contains main_code_header

        inl new_code' = $'$"{!new_code}\\n\\n{!main_code}\\n"'
        inl new_code =
            if cached
            then new_code
            else
                inl runtime_contract =
                    match runtime with
                    | Some (Contract _) => true
                    | _ => false

                new_code'
                |> sm'.replace
                    ("),)" ++# !\($'"\\\";\\\".into()"'))
                    "));"
                |> sm'.replace
                    ("},)" ++# !\($'"\\\";\\\".into()"'))
                    "});"
                |> sm'.replace_regex
                    "\\s\\sdefaultOf\\(\\);"
                    " defaultOf::<()>();"
                |> sm'.replace_regex
                    "\\s\\sgetZero\\(\\);"
                    " getZero::<()>();"
                |> sm'.replace
                    ("(&e.get_Curren" ++# !\($'"\\\"t\\\".into()"'))
                    "(e.get_Current"
                |> sm'.replace
                    ("getNull" ++# !\($'"\\\"::<()>()\\\".into()"'))
                    "fable_library_rust::Native_::getZero()"


                |> sm'.replace
                    ("null::<()>(" ++# !\($'$"\\\")\\\".into()"'))
                    "fable_library_rust::Native_::getZero()"
                |> sm'.replace_regex
                    "null::<\\(\\)>\\(\\)"
                    "fable_library_rust::Native_::getZero()"

                |> sm'.replace_regex
                    "\\(null::<\\(\\)>\\(\\)"
                    "(null()"
                |> sm'.replace_regex
                    " null::<\\(\\)>\\(\\)"
                    " null()"
                |> sm'.replace_regex
                    "unbox::<bool>\\(null\\(\\)"
                    "false"
                |> sm'.replace_regex
                    "unbox::<string>\\(null\\(\\)"
                    "fable_library_rust::Native_::getZero()"
                |> sm'.replace_regex
                    "unbox::<i32>\\(null\\(\\)"
                    "0"
                |> sm'.replace_regex
                    "unbox::<i32>\\(null::<\\(\\)>\\(\\)\\)"
                    "0"
                |> sm'.replace_regex
                    "null\\(\\)"
                    "fable_library_rust::Native_::getZero()"

                |> sm'.replace_regex
                    "\\s\\sfable_library_rust::Native_::getZero\\(\\);"
                    " fable_library_rust::Native_::getZero::<()>();"

                |> sm'.replace
                    " gen:"
                    " f:"
                |> sm'.replace_regex
                    "\\(gen\\("
                    "(f("
                |> sm'.replace_regex
                    "\\(gen,"
                    "(f,"
                |> sm'.replace
                    " gen "
                    " f "

                |> sm'.replace
                    "::Slice'_"
                    "::Slice__"
                |> sm'.replace
                    " Slice'_"
                    " Slice__"
                |> sm'.replace
                    ("defaultOf()" ++# !\($'"\\\",\\\".into()"'))
                    "defaultOf::<std::sync::Arc<dyn IDisposable>>(),"
                |> sm'.replace
                    ("__self" ++# !\($'"\\\"__.\\\".into()"'))
                    "self."
                |> sm'.replace
                    ("_self" ++# !\($'"\\\"_.\\\".into()"'))
                    "self."
                |> sm'.replace
                    ("get_or_insert_wit" ++# !\($'"\\\"h\\\".into()"'))
                    "get_or_init"
                |> sm'.replace
                    ("use fable_library_rust::System::Collections::Concurrent::ConcurrentStack_1" ++# !\($'"\\\";\\\".into()"'))
                    "type ConcurrentStack_1<T> = T;"
                |> sm'.replace
                    ("use fable_library_rust::System::TimeZoneInfo" ++# !\($'"\\\";\\\".into()"'))
                    "type TimeZoneInfo = i64;"
                |> sm'.replace
                    ("use fable_library_rust::System::Threading::Tasks::TaskCanceledException" ++# !\($'"\\\";\\\".into()"'))
                    "type TaskCanceledException = ();"
                |> if static_do_bindings
                    then id
                    else sm'.replace
                            on_startup_text
                            ("// " ++# on_startup_text)
                |> if runtime_contract |> not
                    then id
                    else sm'.replace
                            ("use fable_library_rust::DateTime_::DateTime" ++# ";")
                            "type DateTime = ();"

        if not cached then
            new_code
            |> file_system.write_all_text_exists new_code_path

        inl command =
            if runtime <> None
            then $'$"cargo +nightly-2024-07-14 build --timings --release --target wasm32-unknown-unknown --manifest-path \\\"{!cargo_toml_path}\\\""'
            else $'$"cargo run --timings --manifest-path \\\"{!cargo_toml_path}\\\""'
        inl environment_variables =
            if runtime <> None
            then ;[]
            else
                inl fast = false
                ;[
                    "TRACE_LEVEL", "Verbose"
                    "RUSTC_WRAPPER", "sccache"
                    "RUST_BACKTRACE", "full"
                    "RUSTFLAGS",
                    if fast
                    then "-C prefer-dynamic -C strip=symbols -C link-arg=-s -C debuginfo=0"
                    else "-C prefer-dynamic"
                ]
        inl exit_code, cargo_result =
            execution_options fun x => { x with
                command
                environment_variables
                working_directory = workspace_root_external |> resultm.box |> resultm.ok'
            }
            |> execute_with_options

        inl result =
            if runtime = None then
                inl external_command =
                    inl vars =
                        a environment_variables
                        |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                        |> fun x => x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat ";"
                    inl command =
                        a ;[
                            vars
                            command
                        ]
                        |> fun x => x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat ";"
                    $'$"pwsh -c \'{!command}\'"' : string
                if exit_code <>. 0 then
                    trace Critical
                        fun () => "spiral.process_rust / error"
                        fun () => { exit_code new_code_path external_command cleanup cargo_result }
                    result'
                else
                    inl output =
                        try
                            fun () =>
                                cargo_result
                                |> sm'.split "\n"
                                |> fun x => a x : _ i32 _
                                |> am'.skip_while fun line =>
                                    (line |> sm'.contains "profile [optimized] target" |> not)
                                        && (line |> sm'.contains "profile [unoptimized] target" |> not)
                                        && (line |> sm'.contains "profile [unoptimized + debuginfo] target" |> not)
                                |> am'.skip 2
                                |> seq.of_array
                                |> sm'.concat "\n"
                            fun ex =>
                                trace Critical
                                    fun () => "spiral.process_rust / Exception"
                                    fun () => { ex new_code_path external_command cargo_result }
                                None
                        |> optionm'.box
                        |> optionm'.unwrap
                    { result' with
                        code = Some new_code
                        code_path = Some new_code_path
                        output = Some output
                    }
            else
                inl wasm_path : string =
                    $'$"target/spiral/{!workspace_name}/target/wasm32-unknown-unknown/release/spiral_{!hash}.wasm"'

                inl command =
                    inl invoke_block_path = "scripts/invoke-block.ps1"
                    inl spiral_wasm_command : string =
                        inl runtime_cmd =
                            match runtime with
                            | Some (Wasm cmd) => cmd
                            | Some (Contract cmd) => cmd
                            | _ => ""
                        $'$"\'deps/spiral/workspace/target/release/spiral_wasm -w {!wasm_path} -t debug {!runtime_cmd}\'"'
                    inl automation = "AUTOMATION" |> env.get_environment_variable
                    $'$"pwsh -c \\\"pwsh {!invoke_block_path} {!spiral_wasm_command} -Linux -EnvironmentVariables AUTOMATION={!automation}\`nNEAR_RPC_TIMEOUT_SECS=100\\\""'

                if exit_code = 0 then
                    inl exit_code, spiral_wasm_result =
                        execution_options fun x => { x with
                            command
                            working_directory = workspace_root |> optionm'.some'
                        }
                        |> execute_with_options

                    if exit_code = 0 then
                        { result' with
                            code = Some new_code
                            code_path = Some new_code_path
                            output = Some spiral_wasm_result
                        }
                    else
                        trace Critical
                            fun () => "spiral.process_rust / wasm error"
                            fun () => {
                                exit_code new_code_path cargo_result cleanup
                                spiral_wasm_result = $'$"\\n{!spiral_wasm_result}"' : string
                            }
                        result'
                else
                    trace Critical
                        fun () => "spiral.process_rust / cargo error"
                        fun () => {
                            exit_code new_code_path wasm_path command cleanup
                            cargo_result = $'$"\\n{!cargo_result}"' : string
                        }
                    result'

        inl ci = "CI" |> env.get_environment_variable

        if cleanup || ci <> "" then
            package_dir |> file_system.directory_delete true

            inl cleanup =
                inl build_target =
                    if runtime <> None
                    then "wasm32-unknown-unknown/release"
                    else "debug"

                [ ".d"; ".exe"; ".pdb"; ".wasm"; "" ]
                |> listm.map fun ext =>
                    workspace_dir </> $'$"target/{!build_target}/spiral_{!hash}{!ext}"'
                |> listm.map fun path => path, path |> file_system.file_exists

            trace Verbose
                fun () => "spiral.process_rust / cleanup"
                fun () => { new_code_path cleanup }

            cleanup
            |> listm'.filter snd
            |> listm.iter (fst >> file_system.file_delete)

        result

#!markdown

## dib_export

#!markdown

### escape_cell (test)

#!spiral

//// test
//// test_force

inl escape_cell input =
    input
    |> sm'.split "\n"
    |> am'.to_list_base'
    |> listm'.unbox
    |> listm.map function
        | line when (line |> sm'.starts_with "\\#!") || (line |> sm'.starts_with "\\#r") =>
            inl len = line |> sm'.length
            let rec 루프 i =
                if i >= len
                then line
                else
                    match line |> sm'.index i with
                    | '\\' =>
                        match line |> sm'.index (i + 1) with
                        | '#' => (line |> sm'.slice 0i32 i) ++# (line |> sm'.slice (i + 1) (len - i - 1))
                        | _ => 루프 (i + 1)
                    | _ => 루프 (i + 1)
            루프 0
        | line => line
    |> sm'.concat_list "\n"

#!spiral

//// test
///! fsharp
///! gleam

"a\n\#!magic\nb\n"
|> escape_cell
|> _assert_eq "a\n#!magic\nb\n"

#!markdown

### magic_marker

#!spiral

inl magic_marker () : parser string =
    "#!" |> p_string

#!spiral

//// test

"#!magic"
|> run_parser (magic_marker ())
|> unwrap_format
|> _assert_eq $$("#!", "magic", new_parser_state 0 1 3 7)

#!spiral

//// test

"##!magic"
|> run_parser (magic_marker ())
|> resultm.map_error eval
|> sm'.format_debug
|> _assert_eq (
    "US3_1\n  \"parsing.p_string / unexpected string / { "
    ++# $'"expected = ##!!; got = ####; rest = ####!!magic; s = !(new_parser_state 0 1 1 8) }\\\""'
)

#!spiral

//// test

"\n#!x"
|> run_parser ((new_line () >>. magic_marker ()) <|> (eof () >>. p_return "") |> look_ahead)
|> unwrap_format
|> _assert_eq $$("#!", "\n#!x", new_parser_state 0 1 1 4)

#!markdown

### magic_command

#!spiral

inl magic_command () =
    magic_marker ()
    >>. many_chars_till (any_char ()) (new_line ())
    |>> fun s => fun () => s () |> sm'.trim

#!spiral

//// test
///! fsharp
///! gleam

"#!magic\n\na"
|> run_parser (magic_command ())
|> unwrap_format
|> _assert_eq $$("magic", "\n\na", new_parser_state 0 1 8 10)

#!spiral

//// test

" #!magic\n\na"
|> run_parser (magic_command ())
|> resultm.map_error eval
|> sm'.format_debug
|> _assert_eq (
    "US5_1\n  \"parsing.p_string / unexpected string / { "
    ++# $'"expected = ##!!; got =  ##; rest =  ##!!magic\n\na; s = !(new_parser_state 0 1 1 11) }\\\""'
)

#!markdown

### content

#!spiral

inl content () =
    new_line () >>. magic_marker () <|> eof () >>. p_return ""
    |> look_ahead
    |> many_chars_till (any_char ())
    |>> fun s => fun () => s () |> sm'.trim

#!spiral

//// test

"#!magic\n\n\na\n\n\n"
|> run_parser (content ())
|> unwrap_format
|> _assert_eq $$("#!magic\n\n\na", "", new_parser_state 14 7 1 14)

#!markdown

### dib_output

#!spiral

union dib_output =
    | Fs
    | Md
    | Spi
    | Spir

#!markdown

### magic

#!spiral

union magic =
    | Fsharp
    | Markdown
    | Spiral : dib_output
    | Magic : string

#!markdown

### kernel_outputs

#!spiral

inl kernel_outputs = function
    | Fsharp => [ Fs ]
    | Markdown => [ Md ]
    | Spiral output => [ output ]
    | _ => []

#!markdown

### block

#!spiral

type block =
    {
        magic : magic
        content : () -> string
    }

inl block () =
    pipe2
        (magic_command ())
        (content ())
        fun magic, content =>
            inl magic, content =
                match magic () with
                | "fsharp" => Fsharp, content
                | "markdown" => Markdown, content
                | "spiral" =>
                    inl content = content ()
                    inl output =
                        if content |> sm'.contains "//// real\n"
                        then Spir
                        else Spi
                    inl content () =
                        if output = Spi
                        then content
                        else
                            content
                            |> sm'.replace "//// real\n\n" ""
                            |> sm'.replace "//// real\n" ""
                    output |> Spiral, content
                | magic => magic |> Magic, content
            {
                magic = magic
                content = content
            }

#!spiral

//// test

"#!magic\n\n\na\n\n\n"
|> run_parser (block ())
|> resultm.map fun block, b, s => { block with content = block.content () }, b, s
|> unwrap_format
|> _assert_eq $$(Magic "magic", "a", "", new_parser_state 14 7 1 14)

#!markdown

### blocks

#!spiral

inl blocks () =
    new_lines ()
    >>. sep_end_by (block ()) (new_lines1 ())

#!spiral

//// test
///! fsharp
///! gleam

"#!magic1\n\na\n\n\#!magic2\n\nb\n\n"
|> escape_cell
|> run_parser (blocks ())
|> resultm.map fun a, b, s => (a |> listm.map fun block => { block with content = block.content () }), b, s
|> unwrap_format
|> _assert_eq $$(
    [
        { magic = Magic "magic1"; content = "a" }
        { magic = Magic "magic2"; content = "b" }
    ],
    "",
    new_parser_state 26 9 1 26
)

#!markdown

### format_block

#!spiral

inl format_block output (block : block) =
    match output, block with
    | output, { magic = (Markdown) content = content } =>
        inl markdown_comment =
            match output with
            | Spi | Spir => "/// "
            | Fs => "/// "
            | _ => ""
        content ()
        |> sm'.split "\n"
        |> am'.to_list_base'
        |> listm'.unbox
        |> listm.map (sm'.trim_end [])
        |> listm'.filter (sm'.ends_with " (test)" >> not)
        |> listm.map function
            | "" => markdown_comment
            | line =>
                inl len = line |> sm'.length
                let rec 루프 i =
                    if i >= len
                    then line
                    else
                        match line |> sm'.index i with
                        | ' ' | '\t' => 루프 (i + 1)
                        | _ =>
                            (line |> sm'.slice 0i32 (i - 1))
                            ++# markdown_comment
                            ++# (line |> sm'.slice i (len - 1))
                루프 0
        |> sm'.concat_list "\n"
    | Fs, { magic = (Fsharp) content = content } =>
        inl trimmed_content = content () |> sm'.trim
        if (trimmed_content |> sm'.contains "//// test\n")
            || (trimmed_content |> sm'.contains "//// ignore\n")
        then ""
        else
            content ()
            |> sm'.split "\n"
            |> am'.to_list_base'
            |> listm'.unbox
            |> listm'.filter (sm'.trim_start [] >> sm'.starts_with "#r" >> not)
            |> sm'.concat_list "\n"
    | (Spi | Spir), { magic = (Spiral output') content = content } when output' = output =>
        inl trimmed_content = content () |> sm'.trim
        if (trimmed_content |> sm'.contains "//// test\n")
            || (trimmed_content |> sm'.contains "//// ignore\n")
        then ""
        else content ()
    | _ => ""

#!spiral

//// test

"#!markdown\n\n\na\n\n    b\n\nc\n\n\n\#!markdown\n\n\nc\n\n\n\#!fsharp\n\n\nlet a = 1"
|> escape_cell
|> run_parser (block ())
|> function
    | Ok (block, _, _) => format_block Fs block
    | Error msg => msg () |> failwith
|> _assert_eq "/// a\n/// \n    /// b\n/// \n/// c"

#!markdown

### format_blocks

#!spiral

inl format_blocks output blocks =
    blocks
    |> listm.map fun block =>
        block, format_block output block
    |> listm'.filter (snd >> (<>) "")
    |> fun list =>
        (list, (None, []))
        ||> listm.foldBack (fun (block, content) (last_magic, acc) =>
            inl line_break =
                if block.magic = Markdown && last_magic <> Some Markdown && last_magic <> None
                then ""
                else "\n"
            Some block.magic, content ++# line_break :: acc
        )
    |> snd
    |> sm'.concat_list "\n"

#!spiral

//// test

"#!markdown\n\n\na\n\nb\n\n\n\#!markdown\n\n\nc\n\n\n\#!fsharp\n\n\nlet a = 1\n\n\#!markdown\n\nd (test)\n\n\#!fsharp\n\n//// test\n\nlet a = 2\n\n\#!markdown\n\ne\n\n\#!fsharp\n\nlet a = 3"
|> escape_cell
|> run_parser (blocks ())
|> function
    | Ok (blocks, _, _) => format_blocks Fs blocks
    | Error msg => msg () |> failwith
|> _assert_eq "/// a\n/// \n/// b\n\n/// c\nlet a = 1\n\n/// e\nlet a = 3\n"

#!markdown

### indent_block

#!spiral

inl indent_block (block : block) =
    { block with
        content = fun () =>
            (([], false), block.content () |> sm'.split "\n" |> am'.to_list_base' |> listm'.unbox)
            ||> listm.fold fun (lines, is_multiline) line =>
                inl trimmed_line = line |> sm'.trim
                if trimmed_line = ""
                then "" :: lines, is_multiline
                else
                    inl single_quote_line () =
                        (trimmed_line
                            |> sm'.to_char_list
                            |> listm.map ((=) '"' >> convert.convert)
                            |> listm'.sum) = 1i32
                        && trimmed_line |> sm'.contains "'\"'" |> not
                        && trimmed_line |> sm'.ends_with "{" |> not
                        && trimmed_line |> sm'.ends_with "{|" |> not
                        && trimmed_line |> sm'.starts_with "}" |> not
                        && trimmed_line |> sm'.starts_with "|}" |> not

                    match is_multiline, trimmed_line |> sm'.split_string ;[ "\"\"\"" ] with
                    | false, ;[ _; _ ] =>
                        "    " ++# line :: lines, true

                    | true, ;[ _; _ ] =>
                        line :: lines, false

                    | false, _ when single_quote_line () =>
                        "    " ++# line :: lines, true

                    | false, _ when line |> sm'.starts_with "#" && block.magic = Fsharp =>
                        line :: lines, false

                    | false, _ =>
                        "    " ++# line :: lines, false

                    | true, _ when single_quote_line () && (line |> sm'.starts_with "    ") =>
                        "    " ++# line :: lines, false

                    | true, _ when single_quote_line () =>
                        line :: lines, false

                    | true, _ =>
                        line :: lines, true
            |> fst
            |> listm.rev
            |> sm'.concat_list "\n"
    }

#!markdown

### parse

#!spiral

inl parse output input =
    match input |> run_parser (blocks ()) with
    | Ok (blocks, _, _) =>
        blocks
        |> listm'.filter fun block =>
            block.magic |> kernel_outputs |> listm'.contains output || block.magic = Markdown
        |> listm.map Some
        |> fun x => x ++ [ None ]
        |> listm'.pairwise
        |> listm'.choose function
            | Some { magic = (Markdown) } as block, Some { magic = (Markdown) } => block
            | Some { magic = (Markdown) } as block, Some { magic = magic }
                when magic |> kernel_outputs |> listm'.contains output => block
            | Some { magic = (Markdown) } as block, _ when output = Md => block
            | Some { magic = (Markdown) }, _ => None
            | Some block, _ => Some block
            | _ => None
        |> listm.map fun block => block, block.content ()
        |> listm.fold
            fun acc, indent => function
                | ({ magic = (Markdown) } : block) as block, content
                    when output = Fs
                            && content |> sm'.starts_with "# "
                            && content |> sm'.ends_with ")"
                    =>
                    match sm'.index_of " (" content, sm'.last_index_of ")" content with
                    | i_open, i_close when i_open > 1 && i_close > i_open + 1 =>
                        inl module_name =
                            content |> sm'.substring 2 (i_open - 2) |> sm'.trim
                        inl namespace_name =
                            content |> sm'.substring (i_open + 2) (i_close - (i_open + 2)) |> sm'.trim

                        inl module_block =
                            {
                                magic = Fsharp
                                content = fun () =>
                                    "#if !INTERACTIVE\nnamespace " ++# namespace_name
                                    ++\# "#endif\n\nmodule " ++# module_name ++# " ="
                            }

                        module_block :: acc, (indent + 1)
                    | b => { block with magic = Markdown } :: acc, indent
                | block, _ when indent > 0 =>
                    indent_block block :: acc, indent
                | block, _ => block :: acc, indent
            ([], 0i32)
        |> fst
        |> listm.rev
        |> Ok
    | Error error_msg => error_msg |> Error

#!spiral

//// test
//// test_force

inl example1 () =
    "#!meta"
    ++\# ""
    ++\# "{\"kernelInfo\":{\"defaultKernelName\":\"fsharp\",\"items\":[{\"aliases\":[],\"name\":\"fsharp\"},{\"aliases\":[],\"name\":\"fsharp\"}]}}"
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "# TestModule (TestNamespace)"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "\#!import file.dib"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "\#r \"nuget:Expecto\""
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "## ParserLibrary"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "open System"
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "## x (test)"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "//// ignore"
    ++\# ""
    ++\# "let x = 1"
    ++\# ""
    ++\# "\#!spiral"
    ++\# ""
    ++\# "//// test"
    ++\# ""
    ++\# "inl x = 1i32"
    ++\# ""
    ++\# "\#!spiral"
    ++\# ""
    ++\# "//// real"
    ++\# ""
    ++\# "inl x = 2i32"
    ++\# ""
    ++\# "\#!spiral"
    ++\# ""
    ++\# "inl x = 3i32"
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "### TextInput"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "let str1 = \"abc"
    ++\# "def\""
    ++\# ""
    ++\# "let str2 ="
    ++\# "    \"abc\\"
    ++\# "def\""
    ++\# ""
    ++\# "let str3 ="
    ++\# "    $\"1{"
    ++\# "        1"
    ++\# "    }1\""
    ++\# ""
    ++\# "let str4 ="
    ++\# "    $\"1{({|"
    ++\# "        a = 1"
    ++\# "    |}).a}1\""
    ++\# ""
    ++\# "let str5 ="
    ++\# "    \"abc \\"
    ++\# "        def\""
    ++\# ""
    ++\# "let x ="
    ++\# "    match '\"' with"
    ++\# "    | '\"' -> true"
    ++\# "    | _ -> false"
    ++\# ""
    ++\# "let long1 = \"\"\"a\"\"\""
    ++\# ""
    ++\# "let long2 ="
    ++\# "    \"\"\""
    ++\# "a"
    ++\# "\"\"\""
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "type Position ="
    ++\# "    {"
    ++\# "#if INTERACTIVE"
    ++\# "        line : string"
    ++\# "#else"
    ++\# "        line : int"
    ++\# "#endif"
    ++\# "        column : int"
    ++\# "    }"
    |> escape_cell

#!spiral

//// test

example1 ()
|> parse Fs
|> resultm.get
|> (format_blocks Fs)
|> _assert_eq (
    "#if !INTERACTIVE"
    ++\# "namespace TestNamespace"
    ++\# "#endif"
    ++\# ""
    ++\# "module TestModule ="
    ++\# ""
    ++\# "    /// ## ParserLibrary"
    ++\# "    open System"
    ++\# ""
    ++\# "    /// ### TextInput"
    ++\# "    let str1 = \"abc"
    ++\# "def\""
    ++\# ""
    ++\# "    let str2 ="
    ++\# "        \"abc\\"
    ++\# "def\""
    ++\# ""
    ++\# "    let str3 ="
    ++\# "        $\"1{"
    ++\# "            1"
    ++\# "        }1\""
    ++\# ""
    ++\# "    let str4 ="
    ++\# "        $\"1{({|"
    ++\# "            a = 1"
    ++\# "        |}).a}1\""
    ++\# ""
    ++\# "    let str5 ="
    ++\# "        \"abc \\"
    ++\# "            def\""
    ++\# ""
    ++\# "    let x ="
    ++\# "        match '\"' with"
    ++\# "        | '\"' -> true"
    ++\# "        | _ -> false"
    ++\# ""
    ++\# "    let long1 = \"\"\"a\"\"\""
    ++\# ""
    ++\# "    let long2 ="
    ++\# "        \"\"\""
    ++\# "a"
    ++\# "\"\"\""
    ++\# ""
    ++\# "    type Position ="
    ++\# "        {"
    ++\# "#if INTERACTIVE"
    ++\# "            line : string"
    ++\# "#else"
    ++\# "            line : int"
    ++\# "#endif"
    ++\# "            column : int"
    ++\# "        }"
    ++\# ""
)

#!spiral

//// test

example1 ()
|> parse Md
|> resultm.get
|> (format_blocks Md)
|> _assert_eq (
    "# TestModule (TestNamespace)"
    ++\# ""
    ++\# "## ParserLibrary"
    ++\# ""
    ++\# "### TextInput"
    ++\# ""
)

#!spiral

//// test

example1 ()
|> parse Spi
|> resultm.get
|> (format_blocks Spi)
|> _assert_eq (
    "/// # TestModule (TestNamespace)"
    ++\# ""
    ++\# "/// ## ParserLibrary"
    ++\# "inl x = 3i32"
    ++\# ""
)

#!spiral

//// test
///! fsharp
///! gleam
///! rust
///! cuda

example1 ()
|> parse Spir
|> resultm.get
|> (format_blocks Spir)
|> _assert_eq (
    "/// # TestModule (TestNamespace)"
    ++\# ""
    ++\# "/// ## ParserLibrary"
    ++\# "inl x = 2i32"
    ++\# ""
)

#!markdown

### parse_dib_code

#!spiral

inl parse_dib_code output file =
    trace Debug
        (fun () => "spiral.parse_dib_code")
        fun () => { output = output |> reflection.union_to_string; file }
    inl input = file |> file_system.read_all_text
    match parse output input with
    | Ok blocks => blocks |> format_blocks output
    | Error msg => msg () |> failwith

#!markdown

### write_dib_code

#!spiral

inl write_dib_code output path =
    trace Debug
        (fun () => "spiral.write_dib_code")
        (fun () => { output = output |> reflection.union_to_string; path })
    inl result = parse_dib_code output path
    inl path_dir = path |> file_system.directory_get_parent |> optionm'.default_value' ""
    inl file_name_without_ext =
        match output, path |> file_system.get_file_name_without_extension with
        | Spir, file_name_without_ext => file_name_without_ext ++# "_real"
        | _, file_name_without_ext => file_name_without_ext
    inl output_path =
        path_dir </> (file_name_without_ext ++# "." ++# (output |> reflection.union_to_string |> sm'.to_lower))
    result |> file_system.write_all_text_exists output_path

#!markdown

### process_dib_export

#!spiral

inl process_dib_export { entries } =
    entries
    |> async.into_par_iter
    |> async.par_map fun path, export =>
        path
        |> file_system.get_full_path
        |> write_dib_code export
    |> async.par_collect
    |> ignore
    ;[]

#!markdown

## dib

#!markdown

### process_dib

#!spiral

inl process_dib { path retries working_directory cleanup } =
    inl html_path = $'$"{!path}.html"'
    inl ipynb_path = $'$"{!path}.ipynb"'

    inl exit_code, repl_result =
        let rec 루프 retry =
            inl exit_code, repl_result =
                runtime.execution_options fun x => { x with
                    command = $'$"dotnet repl --exit-after-run --run \\\"{!path}\\\" --output-path \\\"{!ipynb_path}\\\""'
                    environment_variables = ;[
                        "TRACE_LEVEL", "Verbose"
                        "AUTOMATION", "True"
                    ]
                    trace = false
                    working_directory = working_directory |> optionm'.box
                }
                |> runtime.execute_with_options

            if exit_code = 0 || retry >= retries then
                ipynb_path
                |> file_system.read_all_text
                |> sm'.replace "\r\n" "\n"
                |> sm'.replace "\\r\\n" "\\n"
                |> file_system.write_all_text ipynb_path

                exit_code, repl_result
            else
                trace Warning
                    fun () => "spiral.process_dib / repl error"
                    fun () => { exit_code repl_result retry = $'$"{!retry}/{!retries}"' : string }
                루프 (retry + 1)
        루프 1

    inl exit_code, result =
        if exit_code <>. 0
        then exit_code, repl_result
        else
            inl exit_code, jupyter_result =
                runtime.execution_options fun x => { x with
                    command = $'$"jupyter nbconvert \\\"{!ipynb_path}\\\" --to html --HTMLExporter.theme=dark"'
                }
                |> runtime.execute_with_options

            trace Debug
                fun () => "spiral.process_dib / dib / jupyter nbconvert"
                fun () => { exit_code jupyter_result_length = jupyter_result |> sm'.length : i32 }

            if exit_code <>. 0
            then exit_code, $'$"repl_result: {!repl_result}\n\njupyter_result: {!jupyter_result}"'
            else
                html_path
                |> file_system.read_all_text
                |> sm'.replace "\r\n" "\n"
                |> file_system.write_all_text html_path

                inl exit_code, pwsh_replace_html_result =
                    runtime.execution_options fun x => { x with
                        command = $'$"pwsh -c \\\"$counter = 1; $path = \'{!(html_path |> sm'.replace "'" "''")}\'; (Get-Content $path -Raw) -replace \'(id=\\\\\\"cell-id=)[a-fA-F0-9]{{8}}\', {{ $_.Groups[1].Value + $counter++ }} | Set-Content $path\\\""'
                    }
                    |> runtime.execute_with_options

                trace Debug
                    fun () => "spiral.run / dib / html cell ids"
                    fun () => { exit_code pwsh_replace_html_result_length = pwsh_replace_html_result |> sm'.length : i32 }

                exit_code, $'$"repl_result: {!repl_result}\n\njupyter_result: {!jupyter_result}\n\npwsh_replace_html_result: {!pwsh_replace_html_result}"'

    inl ci = "CI" |> env.get_environment_variable

    if cleanup && ci = "" then
        ipynb_path |> file_system.file_delete
        html_path |> file_system.file_delete

    trace Debug
        fun () => "spiral.process_dib / dib"
        fun () => { exit_code result_length = result |> sm'.length : i32 }

    if exit_code <>. 0
    then $'$"spiral.process_dib / dib / exit_code: {!exit_code} / result: \'{!result}\'"' |> failwith
    ;[
        "stdio",
        result
    ]

#!markdown

## typescript

#!markdown

### process_typescript

#!spiral

inl process_typescript { fs_path deps trace_level } =
    inl extension = "ts"

    inl code = fs_path |> file_system.read_all_text

    inl hash = { extension code } |> sm'.format |> crypto.hash_text

    inl workspace_name = "spiral"

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir =
        get_package_dir
            { workspace_root name = workspace_name; target = Some TypeScript; hash = hash |> Some }

    inl fsproj_path =
        persist_code_project {
            workspace_root
            package_dir
            packages = [ "Fable.Core", "4.3.0" ]
            modules = []
            name = workspace_name
            code
        }

    inl lib_path = workspace_root </> "lib/typescript/fable/fable_modules"
    inl lib_dir_prefix = $'$"fable-library-{!extension}"'
    inl lib_dir_prefix' = join lib_dir_prefix

    inl versions : _ (string * string) =
        lib_path
        |> file_system.new_walk_dir
        |> file_system.walk_dir_filter fun entry => async.new_future_move_send fun () =>
            entry
            |> file_system.dir_entry_file_type
            |> async.await_send
            |> resultm.map_error' sm'.format'
            |> resultm.unbox
            |> function
                | Ok file_type when file_type |> file_system.file_type_is_dir |> not => file_system.Ignore
                | _ =>
                    inl path =
                        entry
                        |> file_system.dir_entry_path
                        |> file_system.path_buf_display
                        |> sm'.format'
                        |> sm'.from_std_string
                    if path |> file_system.get_directory_name |> sm'.starts_with lib_dir_prefix |> not
                    then file_system.IgnoreDir
                    else
                        match path |> file_system.directory_get_parent |> optionm'.unbox with
                        | Some parent when parent |> sm'.contains lib_dir_prefix |> not =>
                            file_system.Continue
                        | _ => file_system.IgnoreDir
        |> async.stream_filter_map_futures fun (entry : _ _ file_system.async_walkdir_error) =>
            inl entry = entry |> resultm.map_error' sm'.format' |> resultm.unbox
            match entry with
            | Ok entry =>
                inl path =
                    entry
                    |> file_system.dir_entry_path
                    |> file_system.path_buf_display
                    |> sm'.format'
                    |> sm'.from_std_string
                inl version =
                    $'$"{!lib_dir_prefix'}\\.(?<a>[-\\d\\w.]+)$"'
                    |> sm'.new_regex
                    |> resultm.unwrap'
                    |> sm'.regex_captures path
                    |> am'.from_vec
                    |> fun x => x : _ int _
                    |> am'.try_item 0
                    |> optionm.map (mapm.get "a" >> optionm'.unbox)
                    |> optionm'.flatten
                version
                |> optionm.map fun version =>
                    path, version
            | Error error =>
                trace Critical
                    fun () => "spiral.process_typescript / stream_filter_map"
                    fun () => { error }
                None
            |> optionm'.box
        |> async.stream_collect_futures
        |> async.await
        |> async.into_par_iter
        |> async.par_map id
        |> async.par_collect

    inl version =
        versions
        |> am'.from_vec
        |> fun x => x : _ i32 _
        |> am'.try_item 0

    trace Debug
        fun () => "spiral.process_typescript"
        fun () => { version }


    let link_lib () =
        match version with
        | Some (_path, version) =>
            inl lib_link_target_path = lib_path </> $'$"fable-library-{!extension}.{!version}"'
            inl lib_link_path = package_dir </> $'$"fable_modules/fable-library-{!extension}.{!version}"'
            lib_link_path |> file_system.link_directory lib_link_target_path
            lib_link_target_path </> "fable_modules" |> file_system.directory_delete true
        | None => failwith $'$"spiral.process_typescript / fable library not found / lib_path: {!lib_path}"'

    link_lib ()

    inl exit_code, dotnet_fable_result =
        execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir runtime = None }

    link_lib ()

    if exit_code <>. 0 then
        trace Critical
            fun () => "spiral.process_typescript"
            fun () => { exit_code dotnet_fable_result }
        { extension = Some extension; code = None; code_path = None; output = Some dotnet_fable_result }
    else
        inl deps =
            deps
            |> am'.vec_map fun dep =>
                inl dep = dep |> sm'.from_std_string
                if dep |> sm'.contains "="
                then dep
                else $'$"\\"{!dep}\\":\\"*\\""'
            |> am'.from_vec
            |> fun x => x : _ i32 _
            |> seq.of_array'
            |> sm'.concat ",\n"

        inl package_json_content =
            $'$"{{"'
            +. $'$"  \\\"name\\\": \\\"spiral_{!hash}\\\","'
            +. $'$"  \\\"dependencies\\\": {{"'
            +. deps
            +. $'$"  }},"'
            +. $'$"    \\\"devDependencies\\\": {{"'
            +. $'$"  }},"'
            +. $'$"}}"'

        inl workspace_package_json_content =
            ""

        inl package_json_path = package_dir </> "package.json"

        inl workspace_dir = package_dir </> "../.."
        inl workspace_package_json_path = workspace_dir </> "package.json"

        package_json_content |> file_system.write_all_text_exists package_json_path

        workspace_package_json_content |> file_system.write_all_text_exists workspace_package_json_path

        inl new_code_path = package_dir </> $'$"{!workspace_name}.{!extension}"'
        trace Debug
            fun () => "spiral.process_typescript"
            fun () => { new_code_path }
        inl new_code = new_code_path |> file_system.read_all_text

        inl main_code_header =
            "// spiral.process_typescript"
        inl main_code = "// spiral.process_typescript"

        inl cached = new_code |> sm'.contains main_code_header

        inl new_code =
            if cached
            then new_code
            else
                new_code
                |> sm'.replace
                    $'$"\\\"./fable_modules/fable-library-ts.{!version}/"'
                    $'$"\\\"{!workspace_root}/lib/typescript/fable/fable_modules/fable-library-ts.{!version}/"'
                |> sm'.replace_regex
                    "\\s\\sdefaultOf\\(\\);"
                    " defaultOf::<()>();"

        if not cached then
            $'$"{!new_code}\\n\\n{!main_code}\\n"'
            |> file_system.write_all_text_exists new_code_path

        inl command = $'$"bun --bun run \\\"{!new_code_path}\\\""'
        inl environment_variables =
            match "~/.bun/bin" |> env.append_path with
            | Some path => [ "PATH", path ]
            | None => []
            ++ [
                "TRACE_LEVEL", "Verbose"
            ]
            |> listm'.box
            |> listm'.to_array'
        inl exit_code, run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = workspace_root_external |> resultm.box |> resultm.ok'
            }
            |> runtime.execute_with_options

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code = 0 then
            inl output =
                try
                    fun () =>
                        run_result
                        |> sm'.split "\n"
                        |> fun x => a x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat "\n"
                    fun ex =>
                        trace Critical
                            fun () => "spiral.process_typescript / Exception"
                            fun () => { ex new_code_path external_command run_result }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            {
                extension = Some extension
                code = Some new_code
                code_path = Some new_code_path
                output = Some output
            }
        else
            trace Critical
                fun () => "spiral.process_typescript / error"
                fun () => { exit_code run_result new_code_path external_command }
            { extension = Some extension; code = None; code_path = None; output = None }

#!markdown

## python

#!markdown

### process_python

#!spiral

inl process_python { fs_path deps trace_level } =
    inl extension = "py"
    inl is_trace = trace_level = Verbose
    inl _trace (fn : () -> string) =
        if is_trace
        then trace Info (fun () => $'$"spiral.process_python / {!fn ()}"') id
        else fn () |> console.write_line

    inl code = fs_path |> file_system.read_all_text

    inl hash = { extension code } |> sm'.format |> crypto.hash_text

    inl workspace_name = "spiral"

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir =
        get_package_dir { workspace_root name = workspace_name; target = Some Python; hash = hash |> Some }

    inl fsproj_path =
        persist_code_project {
            workspace_root
            package_dir
            packages = [ "Fable.Core", "4.3.0" ]
            modules = []
            name = workspace_name
            code
        }

    inl lib_path = workspace_root </> "lib/python/fable/fable_modules"

    inl lib_link_target_path = lib_path </> $'$"fable_library"'
    inl lib_link_path = package_dir </> $'$"fable_modules/fable_library"'

    lib_link_path |> file_system.link_directory lib_link_target_path

    inl exit_code, dotnet_fable_result =
        execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir runtime = None }

    if exit_code <>. 0 then
        trace Critical
            fun () => "spiral.process_python"
            fun () => { exit_code dotnet_fable_result }
        { extension = Some extension; code = None; code_path = None; output = Some dotnet_fable_result }
    else
        inl deps =
            deps
            |> am'.vec_map fun dep =>
                inl dep = dep |> sm'.from_std_string
                if dep |> sm'.contains "="
                then dep
                else $'$"\\"{!dep}\\":\\"*\\""'
            |> am'.from_vec
            |> fun x => x : _ i32 _
            |> seq.of_array'
            |> sm'.concat ",\n"

        inl package_json_content =
            $'$"{{"'
            +. $'$"  \\\"name\\\": \\\"spiral_{!hash}\\\","'
            +. $'$"  \\\"dependencies\\\": {{"'
            +. deps
            +. $'$"  }},"'
            +. $'$"    \\\"devDependencies\\\": {{"'
            +. $'$"  }},"'
            +. $'$"}}"'

        inl workspace_package_json_content =
            ""

        inl package_json_path = package_dir </> "package.json"

        inl workspace_dir = package_dir </> "../.."
        inl workspace_package_json_path = workspace_dir </> "package.json"

        package_json_content |> file_system.write_all_text_exists package_json_path

        workspace_package_json_content |> file_system.write_all_text_exists workspace_package_json_path

        inl new_code_path = package_dir </> $'$"{!workspace_name}.{!extension}"'
        trace Debug
            fun () => "spiral.process_python"
            fun () => { new_code_path }
        inl new_code = new_code_path |> file_system.read_all_text

        inl main_code_header =
            "# spiral.process_python"
        inl main_code = "# spiral.process_python"

        inl cached = new_code |> sm'.contains main_code_header

        inl new_code =
            if cached
            then new_code
            else
                new_code
                |> sm'.replace
                    ("),)" +. !\($'"\\\";\\\".into()"'))
                    "));"
                |> sm'.replace_regex
                    "\\s\\sdefaultOf\\(\\);"
                    " defaultOf::<()>();"

        if not cached
        then
            $'$"{!new_code}\\n\\n{!main_code}\\n"'
            |> file_system.write_all_text_exists new_code_path

        inl command = $'$"python \\\"{!new_code_path}\\\""'
        inl environment_variables =
            ;[
                "TRACE_LEVEL", "Verbose"
            ]
        inl exit_code, run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = workspace_root_external |> resultm.box |> resultm.ok'
            }
            |> runtime.execute_with_options

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code = 0 then
            inl output =
                try
                    fun () =>
                        run_result
                        |> sm'.split "\n"
                        |> fun x => a x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat "\n"
                    fun ex =>
                        trace Critical
                            fun () => "spiral.process_python / Exception"
                            fun () => { ex new_code_path external_command run_result }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            {
                extension = Some extension
                code = Some new_code
                code_path = Some new_code_path
                output = Some output
            }
        else
            trace Critical
                fun () => "spiral.process_python / error"
                fun () => { exit_code run_result new_code_path external_command }
            { extension = Some extension; code = None; code_path = None; output = None }

#!markdown

## gleam

#!markdown

### gleam_target

#!spiral

union gleam_target =
    | Erlang
    | JavaScript

#!markdown

### process_gleam

#!spiral

inl process_gleam { gleam_path target deps } =
    inl extension = "gleam"

    inl new_code_path = gleam_path
    inl new_code = new_code_path |> file_system.read_all_text

    inl hash = { extension new_code } |> sm'.format |> crypto.hash_text

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root =
        workspace_root_external |> resultm.box |> resultm.unwrap_or_else id |> file_system.standardize_path

    inl src_dir =
        new_code_path
        |> file_system.directory_get_parent
        |> optionm'.default_value' ""
        |> file_system.standardize_path

    inl package_dir = src_dir </> ".." |> file_system.standardize_path

    fun () =>
        inl ci = "CI" |> env.get_environment_variable
        if ci <> "" then
            package_dir
            |> file_system.directory_delete true
    |> new_disposable
    |> fun x => x : _ ()
    |> use
    |> ignore

    inl manifest_path = package_dir </> "gleam.toml"

    inl deps =
        ;[
            "gleam_stdlib=\"0.57.0\""
            "gleam_time=\">=1.0.0 and <2.0.0\""
            "gleam_erlang=\">=0.34.0 and <1.0.0\""
            "envoy=\">=1.0.0 and <2.0.0\""
            "gary=\">=1.1.0 and <2.0.0\""
            "gtempo=\">=7.1.0 and <8.0.0\""
        ]
        |> am'.to_vec
        |> am'.vec_map sm'.to_std_string
        |> am'.vec_extend deps
        |> am'.vec_map fun dep =>
            inl dep = dep |> sm'.from_std_string
            if dep |> sm'.contains "="
            then dep
            elif dep |> sm'.ends_with "]"
            then dep |> sm'.replace "[" $'$"={{version=\'*\',features=["' |> fun x => $'$"{!x}}}"'
            else $'$"{!dep}=\'*\'"'
        |> am'.from_vec
        |> fun x => x : _ i32 _
        |> seq.of_array'
        |> sm'.concat "\n"

    inl target' = target |> reflection.union_to_string |> sm'.to_lower

    inl manifest =
        inl main =
            if new_code_path |> sm'.contains "_real"
            then "main_real"
            else "main"
        $'$"name = \\\"{!main}\\\""'
        ++\# $'$"target = \\\"{!target'}\\\""'
        ++\# $'$""'
        ++\# $'$"[dependencies]"'
        ++\# $'$"{!deps}"'

    manifest |> file_system.write_all_text_exists manifest_path

    inl exit_code, run_result =
        // runtime.execution_options fun x => { x with
        //     command = $'$"gleam check"'
        //     working_directory = package_dir |> optionm'.some'
        // }
        // |> runtime.execute_with_options
        0i32, ""

    if exit_code <>. 0 then
        trace Critical
            fun () => "spiral.process_gleam / check error"
            fun () => { exit_code run_result new_code_path }
        { extension = Some extension; code = None; code_path = None; output = None }
    else
        inl command =
            if target = Erlang
            then $'$"gleam run --no-print-progress \\\"{!new_code_path}\\\""' : string
            else $'$"gleam build --no-print-progress"'
        inl environment_variables =
            ;[
                "TRACE_LEVEL", ""
                "GLEAM_LOG", ""
                "GLEAM_LOG_NOCOLOUR", ""
            ]
        inl exit_code, run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = package_dir |> optionm'.some'
                stderr = false
            }
            |> runtime.execute_with_options

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code <>. 0 then
            trace Critical
                fun () => "spiral.process_gleam / error"
                fun () => { exit_code run_result new_code_path external_command }
            { extension = Some extension; code = None; code_path = None; output = None }
        else
            inl run_result =
                if target = Erlang
                then run_result
                else
                    inl js_path = $'$"{!package_dir}/build/dev/javascript/main/main.mjs"'
                    inl js_text = js_path |> file_system.read_all_text
                    inl js_text = js_text |> sm'.replace $'$"\#app_"' $'$"\#app_{!hash}"'
                    if js_text |> sm'.ends_with "main()" |> not then
                        $'$"{!js_text}\nmain()"'
                        |> file_system.write_all_text_exists js_path

                    inl exit_code, run_result =
                        runtime.execution_options fun x => { x with
                            command =
                                $'$"bunx --bun esbuild --bundle --minify --loader:.wasm=file --outdir={!src_dir} {!js_path}"'
                            environment_variables =
                                match "~/.bun/bin" |> env.append_path with
                                | Some path => ;[ "PATH", path ]
                                | None => ;[]
                            working_directory = package_dir |> optionm'.some'
                        }
                        |> runtime.execute_with_options

                    if exit_code <>. 0 then
                        trace Critical
                            fun () => "spiral.process_gleam / esbuild error"
                            fun () => { exit_code run_result new_code_path }
                        ""
                    else
                        inl html =
                            $'$"<\!DOCTYPE html>"'
                            ++\# $'$"<html lang=\\\"en\\\">"'
                            ++\# $'$"  <head>"'
                            ++\# $'$"    <meta charset=\\\"UTF-8\\\" />"'
                            ++\# $'$"    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />"'
                            ++\# $'$"    <link"'
                            ++\# $'$"      data-trunk"'
                            ++\# $'$"      rel=\\\"inline\\\""'
                            ++\# $'$"      href=\\\"../build/packages/lustre_ui/priv/static/lustre_ui.css\\\""'
                            ++\# $'$"    />"'
                            ++\# $'$"    <link"'
                            ++\# $'$"      data-trunk"'
                            ++\# $'$"      rel=\\\"inline\\\""'
                            ++\# $'$"      type=\\\"module\\\""'
                            ++\# $'$"      href=\\\"main.js\\\""'
                            ++\# $'$"    />"'
                            ++\# $'$"  </head>"'
                            ++\# $'$"  <body>"'
                            ++\# $'$"    <div id=\\\"app_{!hash}\\\"></div>"'
                            ++\# $'$"  </body>"'
                            ++\# $'$"</html>"'

                        inl html_path = $'$"{!src_dir}/index.html"'
                        html |> file_system.write_all_text_exists html_path

                        "" |> file_system.write_all_text_exists $'$"{!src_dir}/spiral_{!hash}.rs"'

                        inl manifest =
                            $'$"[package]"'
                            ++\# $'$"name = \\\"spiral_{!hash}\\\""'
                            ++\# $'$""'
                            ++\# $'$"[workspace]"'
                            ++\# $'$""'
                            ++\# $'$"[lib]"'
                            ++\# $'$"crate-type = [\\\"cdylib\\\", \\\"rlib\\\"]"'
                            ++\# $'$"path = \\\"spiral_{!hash}.rs\\\""'
                            ++\# $'$""'
                            ++\# $'$"[dependencies]"'

                        manifest |> file_system.write_all_text_exists $'$"{!src_dir}/Cargo.toml"'

                        inl exit_code, run_result =
                            runtime.execution_options fun x => { x with
                                command = $'$"trunk build --release --minify --dist={!src_dir} --public-url=./ --no-sri"'
                                environment_variables =
                                    ;[
                                        "TRUNK_TOOLS_WASM_BINDGEN", "0.2.93"
                                    ]
                                working_directory = src_dir |> optionm'.some'
                            }
                            |> runtime.execute_with_options

                        if exit_code = 0
                        then html_path |> file_system.read_all_text
                        else
                            trace Critical
                                fun () => "spiral.process_gleam / trunk error"
                                fun () => { exit_code run_result new_code_path }
                            ""

            inl run_result' = run_result |> sm'.to_std_string

            inl output =
                try
                    fun () =>
                        run_result
                        |> sm'.split "\n"
                        |> am'.to_vec
                        |> am'.vec_filter fun x =>
                            (x |> sm'.starts_with "{compiling,\"" |> not)
                            && (x |> sm'.starts_with "{compiled," |> not)
                            && (x |> sm'.ends_with ".beam\"}" |> not)
                            && (x |> sm'.starts_with "src\\main.gleam:" |> not)
                            && (x |> sm'.starts_with "src\\main_real.gleam:" |> not)
                            && (x |> sm'.starts_with "src/main.gleam:" |> not)
                            && (x |> sm'.starts_with "src/main_real.gleam:" |> not)
                            && (x |> sm'.starts_with "% " |> not)
                        |> am'.from_vec
                        |> fun x => x : _ int _
                        |> seq.of_array
                        |> sm'.concat "\n"
                        |> sm'.trim_start [ '\n' ]
                    fun ex =>
                        trace Critical
                            fun () => "spiral.process_gleam / Exception"
                            fun () => { ex run_result' new_code_path external_command }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            {
                extension = Some extension
                code = Some new_code
                code_path = Some new_code_path
                output = Some output
            }

#!markdown

## lua

#!markdown

### process_lua

#!spiral

inl process_lua { lua_path } =
    inl extension = "lua"

    inl new_code_path = lua_path
    inl new_code = new_code_path |> file_system.read_all_text

    inl hash = { extension new_code } |> sm'.format |> crypto.hash_text

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root =
        workspace_root_external |> resultm.box |> resultm.unwrap_or_else id |> file_system.standardize_path

    inl src_dir =
        new_code_path
        |> file_system.directory_get_parent
        |> optionm'.default_value' ""
        |> file_system.standardize_path

    inl package_dir = src_dir </> ".." |> file_system.standardize_path

    fun () =>
        inl ci = "CI" |> env.get_environment_variable
        if ci <> "" then
            package_dir
            |> file_system.directory_delete true
    |> new_disposable
    |> fun x => x : _ ()
    |> use
    |> ignore

    inl output = "spiral.process_lua / output"

    {
        extension = Some extension
        code = Some new_code
        code_path = Some new_code_path
        output = Some output
    }

#!markdown

## cuda

#!markdown

### cuda_env

#!spiral

union cuda_env =
    | Pip
    | Poetry

#!markdown

### process_cuda

#!spiral

inl process_cuda { py_path env deps } =
    inl extension = "py"

    inl new_code_path = py_path
    inl new_code = new_code_path |> file_system.read_all_text

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir = new_code_path |> file_system.directory_get_parent |> optionm'.default_value' ""

    inl manifest_path =
        match env with
        | Pip => package_dir </> "requirements.txt"
        | Poetry => package_dir </> "pyproject.toml"

    inl deps =
        deps
        |> am'.vec_map fun dep =>
            inl dep = dep |> sm'.from_std_string
            if dep |> sm'.contains "="
            then dep
            elif dep |> sm'.ends_with "]"
            then dep |> sm'.replace "[" $'$"={{version=\'*\',features=["' |> fun x => $'$"{!x}}}"'
            else $'$"{!dep}=\'*\'"'
        |> am'.from_vec
        |> fun x => x : _ i32 _
        |> seq.of_array'
        |> sm'.concat "\n"

    inl exit_code, run_result =
        if deps = ""
        then 0, ""
        else
            inl manifest =
                match env with
                | Pip =>
                    deps
                | Poetry =>
                    $'$"[tool.poetry]"'
                    ++\# $'$"name = \\\"test\\\""'
                    ++\# $'$"version = \\\"0.0.1\\\""'
                    ++\# $'$"description = \\\"\\\""'
                    ++\# $'$"authors = []"'
                    ++\# $'$""'
                    ++\# $'$"[tool.poetry.dependencies]"'
                    ++\# $'$"python=\\\"~3.12\\\""'
                    ++\# $'$"{!deps}"'
                    ++\# $'$""'
                    ++\# $'$"[build-system]"'
                    ++\# $'$"requires = [\\\"poetry-core\\\"]"'
                    ++\# $'$"build-backend = \\\"poetry.core.masonry.api\\\""'

            manifest |> file_system.write_all_text_exists manifest_path

            runtime.execution_options fun x => { x with
                command =
                    match env with
                    | Pip => $'$"pip install -r requirements.txt"'
                    | Poetry => $'$"poetry install"'
                working_directory = package_dir |> optionm'.some'
            }
            |> runtime.execute_with_options

    if exit_code <>. 0 then
        trace Critical
            fun () => "spiral.process_cuda / env install error"
            fun () => { env exit_code run_result new_code_path }
        { extension = Some extension; code = None; code_path = None; output = None }
    else
        inl command =
            match env with
            | Pip => $'$"python \\\"{!new_code_path}\\\""'
            | Poetry => $'$"poetry run python \\\"{!new_code_path}\\\""'
        inl environment_variables =
            ;[
                "TRACE_LEVEL", "Verbose"
            ]
        inl exit_code, run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = package_dir |> optionm'.some'
            }
            |> runtime.execute_with_options

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code = 0
            || (run_result |> sm'.contains "cupy_backends.cuda.api.runtime.CUDARuntimeError: cudaErrorInsufficientDriver") then
            inl output =
                try
                    fun () =>
                        run_result
                        |> sm'.split "\n"
                        |> fun x => a x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat "\n"
                    fun ex =>
                        trace Critical
                            fun () => "spiral.process_cuda / Exception"
                            fun () => { ex run_result new_code_path external_command }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            {
                extension = Some extension
                code = Some new_code
                code_path = Some new_code_path
                output = Some output
            }
        else
            trace Critical
                fun () => "spiral.process_cuda / error"
                fun () => { exit_code run_result new_code_path external_command }
            { extension = Some extension; code = None; code_path = None; output = None }

#!markdown

## fsharp

#!markdown

### process_fsharp

#!spiral

inl process_fsharp { spi_path } =
    inl extension = "fsx"

    inl new_code_path = spi_path
    inl new_code = new_code_path |> file_system.read_all_text

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl supervisor_path = workspace_root </> $"apps/spiral/dist/Supervisor!(platform.get_executable_suffix ())"
    inl code_dir = new_code_path |> file_system.directory_get_parent |> optionm'.default_value' ""
    inl file_name = new_code_path |> file_system.get_file_name_without_extension
    inl output_path = code_dir </> $'$"{!file_name}.{!extension}"'
    inl command = $'$"{!supervisor_path} --build-file \\\"{!new_code_path}\\\" \\\"{!output_path}\\\""'
    inl environment_variables =
        ;[
            "TRACE_LEVEL", "Verbose"
        ]
    inl exit_code, run_result =
        runtime.execution_options fun x => { x with
            command
            environment_variables
            working_directory = workspace_root_external |> resultm.box |> resultm.ok'
        }
        |> runtime.execute_with_options

    inl external_command =
        inl vars =
            a environment_variables
            |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
            |> fun x => x : _ i32 _
            |> seq.of_array
            |> sm'.concat ";"
        $'$"pwsh -c \'{!vars}; {!command}\'"' : string
    if exit_code = 0 then
        inl output =
            try
                fun () =>
                    run_result
                    |> sm'.split "\n"
                    |> fun x => a x : _ i32 _
                    |> seq.of_array
                    |> sm'.concat "\n"
                fun ex =>
                    trace Critical
                        fun () => "spiral.process_fsharp / Exception"
                        fun () => { ex run_result new_code_path external_command }
                    None
            |> optionm'.box
            |> optionm'.unwrap

        {
            extension = Some extension
            code = Some new_code
            code_path = Some new_code_path
            output = Some output
        }
    else
        trace Critical
            fun () => "spiral.process_fsharp / error"
            fun () => { exit_code run_result new_code_path external_command }
        { extension = Some extension; code = None; code_path = None; output = None }

#!markdown

## run

#!markdown

### get_args

#!spiral

inl get_args () =
    {
        fsharp = "fsharp", {
            spi_path = "spi-path", 's'
        }
        gleam = "gleam", {
            gleam_path = "gleam-path", 'g'
            target = "target", 't'
            deps = "deps", 'd'
        }
        lua = "lua", {
            lua_path = "lua-path", 'l'
        }
        cuda = "cuda", {
            py_path = "py-path", 'p'
            env = "env", 'e'
            deps = "deps", 'd'
        }
        fable = "fable", {
            fs_path = "fs-path", 'f'
            command = "command", 'c'
        }
        rust = "rust", {
            fs_path = "fs-path", 'f'
            deps = "deps", 'd'
            wasm = "wasm", 'w'
            contract = "contract", 'c'
            cleanup = "cleanup", 'l'
        }
        typescript = "typescript", {
            fs_path = "fs-path", 'f'
            deps = "deps", 'd'
        }
        python = "python", {
            fs_path = "fs-path", 'f'
            deps = "deps", 'd'
        }
        dib = "dib", {
            path = "path", 'p'
            retries = "retries", 'r'
            working_directory = "working-directory", 'w'
            cleanup = "cleanup", 'l'
            export = "export", 'e'
        }
        dib_export = "dib-export", {
            entries = "entries", 'e'
        }
    }

#!markdown

### get_command

#!spiral

let get_command () =
    ##"command"
    |> runtime.new_command
    |> runtime.command_subcommand_required true
    |> runtime.command_subcommand (
        ##(get_args () .fsharp |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .fsharp |> snd).spi_path) (
            runtime.arg_required true
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .gleam |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .gleam |> snd).gleam_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .gleam |> snd).target) (
            real runtime.arg_union `gleam_target ignore
        )
        |> runtime.command_init_arg ((get_args () .gleam |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    false
                    (am'.Start (1i32 |> convert.convert : convert.unativeint))
                    (am'.End eval)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .cuda |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .cuda |> snd).py_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .cuda |> snd).env) (
            real runtime.arg_union `cuda_env ignore
        )
        |> runtime.command_init_arg ((get_args () .cuda |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    false
                    (am'.Start (1i32 |> convert.convert : convert.unativeint))
                    (am'.End eval)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .fable |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .fable |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .fable |> snd).command) (
            id
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .rust |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .rust |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .rust |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    false
                    (am'.Start (1i32 |> convert.convert : convert.unativeint))
                    (am'.End eval)
            )
            >> runtime.arg_action runtime.Append
        )
        |> runtime.command_init_arg ((get_args () .rust |> snd).wasm) (
            runtime.arg_num_args_range (
                runtime.new_value_range
                    true
                    (am'.End eval)
                    (am'.End fun _ => (1i32 |> convert.convert : convert.unativeint))
            )
            >> runtime.arg_require_equals true
            >> runtime.arg_default_missing_value ""
        )
        |> runtime.command_init_arg ((get_args () .rust |> snd).contract) (
            runtime.arg_num_args_range (
                runtime.new_value_range
                    true
                    (am'.End eval)
                    (am'.End fun _ => (1i32 |> convert.convert : convert.unativeint))
            )
            >> runtime.arg_require_equals true
            >> runtime.arg_default_missing_value ""
        )
        |> runtime.command_init_arg ((get_args () .rust |> snd).cleanup) (
            runtime.arg_default_value "true"
            >> runtime.arg_action runtime.SetFalse
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .typescript |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .typescript |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .typescript |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    false
                    (am'.Start (1i32 |> convert.convert : convert.unativeint))
                    (am'.End eval)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .python |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .python |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .python |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    false
                    (am'.Start (1i32 |> convert.convert : convert.unativeint))
                    (am'.End eval)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .dib |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .dib |> snd).path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .dib |> snd).retries) (
            runtime.arg_value_parser (runtime.value_parser_expr "u8")
        )
        |> runtime.command_init_arg ((get_args () .dib |> snd).working_directory) (
            id
        )
        |> runtime.command_init_arg ((get_args () .dib |> snd).cleanup) (
            runtime.arg_default_value "true"
            >> runtime.arg_action runtime.SetFalse
        )
    )
    |> runtime.command_subcommand (
        inl parse (s : rust.ref sm'.str) : resultm.result' (sm'.std_string * sm'.std_string) sm'.std_string =
            trace Verbose (fun () => "spiral.get_command") (fun () => { s })
            inl path = "" |> sm'.to_std_string
            inl ext = "" |> sm'.to_std_string
            Ok (path, ext)
            |> resultm.box
        ##(get_args () .dib_export |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .dib_export |> snd).entries) (
            runtime.arg_required true
            // >> runtime.arg_value_parser (!\\(parse, $'"clap::value_parser\!(String).into()"'))
            >> runtime.arg_index 1
            >> runtime.arg_value_names ;[ ##"PATH"; ##"EXT" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    false
                    (am'.Start (2i32 |> convert.convert : convert.unativeint))
                    (am'.End eval)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .lua |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .lua |> snd).lua_path) (
            runtime.arg_required true
            // >> runtime.arg_value_parser (runtime.value_parser_path_buf ())
        )
    )

#!markdown

### run

#!spiral

let rec run trace_level (matches : runtime.arg_matches) : async.future_pin (resultm.result' string string) =
    fun () =>
        match matches |> runtime.matches_subcommand |> optionm'.unbox with
        | Some (subcommand, arg_matches)
                when (subcommand |> sm'.from_std_string) = (get_args () .gleam |> fst) =>

            inl gleam_path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .gleam |> snd).gleam_path |> fst)
                |> optionm'.unbox
                |> optionm.value
                |> sm'.from_std_string

            inl target =
                arg_matches
                |> runtime.matches_get_one ((get_args () .gleam |> snd).target |> fst)
                |> optionm'.unbox
                |> optionm.map (
                    sm'.from_std_string
                    >> reflection.union_try_pick
                )
                |> optionm'.flatten
                |> optionm'.default_value Erlang

            inl deps : am'.vec sm'.std_string =
                arg_matches
                |> runtime.matches_get_many ((get_args () .gleam |> snd).deps |> fst)
                |> optionm'.unbox
                |> optionm'.default_value (;[] |> am'.to_vec)

            inl command_result =
                process_gleam { gleam_path target deps }
                |> fun { extension code output } =>
                    ;[
                        "extension", extension |> optionm'.default_value ""
                        "code", code |> optionm'.default_value ""
                        "output", output |> optionm'.default_value ""
                    ]

            ;[
                "command_result",
                command_result
                |> am'.to_vec
                |> am'.vec_map' fun k, v =>
                    new_pair (sm'.to_std_string k) (sm'.to_std_string v)
                |> mapm.b_tree_map_from_vec_pairs
                |> sm'.serialize
                |> resultm.unwrap'
                |> sm'.from_std_string
            ]

        | Some (subcommand, arg_matches)
                when (subcommand |> sm'.from_std_string) = (get_args () .lua |> fst) =>

            inl lua_path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .lua |> snd).lua_path |> fst)
                |> optionm'.unbox
                |> optionm.value
                |> sm'.from_std_string

            inl command_result =
                process_lua { lua_path }
                |> fun { extension code output } =>
                    ;[
                        "extension", extension |> optionm'.default_value ""
                        "code", code |> optionm'.default_value ""
                        "output", output |> optionm'.default_value ""
                    ]

            ;[
                "command_result",
                command_result
                |> am'.to_vec
                |> am'.vec_map' fun k, v =>
                    new_pair (sm'.to_std_string k) (sm'.to_std_string v)
                |> mapm.b_tree_map_from_vec_pairs
                |> sm'.serialize
                |> resultm.unwrap'
                |> sm'.from_std_string
            ]

        | Some (subcommand, arg_matches)
                when (subcommand |> sm'.from_std_string) = (get_args () .cuda |> fst) =>

            inl py_path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .cuda |> snd).py_path |> fst)
                |> optionm'.unbox
                |> optionm.value
                |> sm'.from_std_string

            inl env =
                arg_matches
                |> runtime.matches_get_one ((get_args () .cuda |> snd).env |> fst)
                |> optionm'.unbox
                |> optionm.map (
                    sm'.from_std_string
                    >> reflection.union_try_pick
                )
                |> optionm'.flatten
                |> optionm'.default_value Pip

            inl deps : am'.vec sm'.std_string =
                arg_matches
                |> runtime.matches_get_many ((get_args () .cuda |> snd).deps |> fst)
                |> optionm'.unbox
                |> optionm'.default_value (;[] |> am'.to_vec)

            inl command_result =
                process_cuda { py_path env deps }
                |> fun { extension code output } =>
                    ;[
                        "extension", extension |> optionm'.default_value ""
                        "code", code |> optionm'.default_value ""
                        "output", output |> optionm'.default_value ""
                    ]

            ;[
                "command_result",
                command_result
                |> am'.to_vec
                |> am'.vec_map' fun k, v =>
                    new_pair (sm'.to_std_string k) (sm'.to_std_string v)
                |> mapm.b_tree_map_from_vec_pairs
                |> sm'.serialize
                |> resultm.unwrap'
                |> sm'.from_std_string
            ]

        | Some (subcommand, arg_matches)
                when (subcommand |> sm'.from_std_string) = (get_args () .fable |> fst) =>

            inl fs_path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .fable |> snd).fs_path |> fst)
                |> optionm'.unbox
                |> optionm.value
                |> sm'.from_std_string

            inl command =
                arg_matches
                |> runtime.matches_get_one ((get_args () .fable |> snd).command |> fst)
                |> optionm'.unbox
                |> optionm.map sm'.from_std_string

            inl command_result =
                match command with
                | Some command =>
                    get_command ()
                    |> runtime.command_get_matches_from (
                        $'$"_ {!command} --fs-path \\\"{!fs_path}\\\""' |> runtime.split_args |> resultm.get
                    )
                    |> run trace_level
                    |> async.await
                    |> resultm.unwrap'
                | None => "{}"

            ;[
                "command_result",
                command_result
            ]

        | Some (subcommand, arg_matches)
            when (subcommand |> sm'.from_std_string) = (get_args () .dib |> fst) =>

            inl path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .dib |> snd).path |> fst)
                |> optionm'.map'' (
                    sm'.from_std_string
                    >> file_system.absolute_path
                )
                |> optionm'.unwrap

            inl retries =
                arg_matches
                |> runtime.matches_get_one ((get_args () .dib |> snd).retries |> fst)
                |> optionm'.default_value' 1u8

            inl working_directory =
                arg_matches
                |> runtime.matches_get_one ((get_args () .dib |> snd).working_directory |> fst)
                |> optionm'.unbox
                |> optionm.map sm'.from_std_string

            inl cleanup =
                arg_matches
                |> runtime.matches_get_flag ((get_args () .dib |> snd).cleanup |> fst)

            process_dib { path retries working_directory cleanup }

        | Some (subcommand, arg_matches)
            when (subcommand |> sm'.from_std_string) = (get_args () .dib_export |> fst) =>

            inl deps : am'.vec (sm'.std_string * sm'.std_string) =
                arg_matches
                |> runtime.matches_get_many ((get_args () .cuda |> snd).deps |> fst)
                |> optionm'.unbox
                |> optionm'.default_value (;[] |> am'.to_vec)

            inl entries =
                arg_matches
                |> runtime.matches_get_many ((get_args () .dib_export |> snd).entries |> fst)
                |> optionm'.unbox
                |> optionm.map (fun (entries : am'.vec sm'.std_string) =>
                    entries
                    |> fun x => !\\(x, $'$"$0.chunks_exact(2).map(|chunk| chunk.to_vec()).collect()"') : am'.vec (am'.vec sm'.std_string)
                    |> am'.vec_map' fun chunk =>
                        inl exts () =
                            reflection.get_union_fields_untag () : _ (_ * dib_output)
                        chunk
                        |> am'.from_vec_base
                        |> am'.to_list_base'
                        |> listm'.unbox
                        |> function
                            | [ path; ext ] =>
                                match ext |> sm'.from_std_string |> reflection.union_try_pick with
                                | Some (ext : dib_output) => (path |> sm'.from_std_string, ext) |> Ok
                                | None => "spiral.run / invalid ext / " ++# ({ ext exts } |> sm'.format) |> Error
                            | _ => "spiral.run / invalid entries / " ++# ({ entries = entries |> rust.clone; exts } |> sm'.format) |> Error
                            |> resultm.get
                    |> am'.from_vec_base
                    |> am'.to_list_base'
                    |> listm'.unbox
                )
                |> optionm'.default_value []
                |> listm'.box
                |> listm'.to_array'
                |> am'.to_vec

            process_dib_export { entries }

        | matches =>
            match matches with
            | Some (subcommand, arg_matches)
                    when (subcommand |> sm'.from_std_string) = (get_args () .rust |> fst) =>

                inl fs_path =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .rust |> snd).fs_path |> fst)
                    |> optionm'.unbox
                    |> optionm.value
                    |> sm'.from_std_string

                inl deps : am'.vec sm'.std_string =
                    arg_matches
                    |> runtime.matches_get_many ((get_args () .rust |> snd).deps |> fst)
                    |> optionm'.unbox
                    |> optionm'.default_value (;[] |> am'.to_vec)

                inl cleanup =
                    arg_matches
                    |> runtime.matches_get_flag ((get_args () .rust |> snd).cleanup |> fst)

                inl wasm =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .rust |> snd).wasm |> fst)
                    |> optionm'.unbox
                    |> optionm.map sm'.from_std_string

                inl contract =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .rust |> snd).contract |> fst)
                    |> optionm'.unbox
                    |> optionm.map sm'.from_std_string

                inl runtime =
                    match wasm, contract with
                    | Some wasm, _ => Wasm wasm |> Some
                    | _, Some contract => Contract contract |> Some
                    | _ => None

                process_rust { fs_path deps trace_level runtime cleanup }

            | Some (subcommand, arg_matches)
                    when (subcommand |> sm'.from_std_string) = (get_args () .typescript |> fst) =>

                inl fs_path =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .typescript |> snd).fs_path |> fst)
                    |> optionm'.unbox
                    |> optionm.value
                    |> sm'.from_std_string

                inl deps : am'.vec sm'.std_string =
                    arg_matches
                    |> runtime.matches_get_many ((get_args () .typescript |> snd).deps |> fst)
                    |> optionm'.unbox
                    |> optionm'.default_value (;[] |> am'.to_vec)

                process_typescript { fs_path deps trace_level }

            | Some (subcommand, arg_matches)
                    when (subcommand |> sm'.from_std_string) = (get_args () .python |> fst) =>
                inl fs_path =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .python |> snd).fs_path |> fst)
                    |> optionm'.unbox
                    |> optionm.value
                    |> sm'.from_std_string

                inl deps : am'.vec sm'.std_string =
                    arg_matches
                    |> runtime.matches_get_many ((get_args () .python |> snd).deps |> fst)
                    |> optionm'.unbox
                    |> optionm'.default_value (;[] |> am'.to_vec)

                process_python { fs_path deps trace_level }

            | Some (subcommand, arg_matches) =>
                trace Debug
                    fun () => "spiral.run / invalid subcommand"
                    fun () => { subcommand arg_matches }

                { extension = None; code = None; code_path = None; output = None }
            | _ =>
                { extension = None; code = None; code_path = None; output = None }
            |> fun { extension code code_path output } =>
                ;[
                    "extension", extension |> optionm'.default_value ""
                    "code", code |> optionm'.default_value ""
                    "code_path", code_path |> optionm'.default_value ""
                    "output", output |> optionm'.default_value ""
                ]
        |> am'.to_vec
        |> am'.vec_map' fun k, v =>
            new_pair (sm'.to_std_string k) (sm'.to_std_string v)
        |> mapm.b_tree_map_from_vec_pairs
        |> sm'.serialize
        |> resultm.map_error' (sm'.format' >> sm'.from_std_string)
        |> resultm.map' sm'.from_std_string
    |> async.new_future_move

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io futures rand rayon regex serde_json sha2

inl file_name = "main.fs"
inl code = "let method0 () =\n    3 - 6 |> System.Console.WriteLine\nmethod0 ()\n"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
disposable |> use |> ignore
inl fs_path = temp_dir </> file_name

code |> file_system.write_all_text fs_path

get_command ()
|> runtime.command_get_matches_from (
    $'$"_ fable -f \\\"{!fs_path}\\\" -c \\\"rust -d regex=\'*\'\\\""'
    |> runtime.split_args
    |> resultm.get
)
|> run Verbose
|> async.block_on_futures
|> resultm.unwrap'
|> sm'.deserialize
|> resultm.unwrap'
|> mapm.get ("command_result" |> sm'.to_std_string)
|> optionm'.unwrap
|> sm'.from_std_string
|> sm'.deserialize
|> resultm.unwrap'
|> fun result =>
    result
    |> mapm.get ("extension" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "rs"
    result
    |> mapm.get ("output" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "-3"

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io futures rand rayon regex serde_json sha2

inl file_name = "main.fs"
inl code = "3 - 6 |> System.Console.WriteLine\n"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
disposable |> use |> ignore
inl fs_path = temp_dir </> file_name

code |> file_system.write_all_text fs_path

get_command ()
|> runtime.command_get_matches_from ($'$"_ fable -f \\\"{!fs_path}\\\" -c \\\"typescript\\\""' |> runtime.split_args |> resultm.get)
|> run Verbose
|> async.block_on_futures
|> resultm.unwrap'
|> sm'.deserialize
|> resultm.unwrap'
|> mapm.get ("command_result" |> sm'.to_std_string)
|> optionm'.unwrap
|> sm'.from_std_string
|> sm'.deserialize
|> resultm.unwrap'
|> fun result =>
    result
    |> mapm.get ("extension" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "ts"
    result
    |> mapm.get ("output" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "-3"

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io futures rand rayon regex serde_json sha2

inl file_name = "main.fs"
inl code = "3 - 6 |> System.Console.WriteLine\n"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
disposable |> use |> ignore
inl fs_path = temp_dir </> file_name

code |> file_system.write_all_text fs_path

get_command ()
|> runtime.command_get_matches_from ($'$"_ fable -f \\\"{!fs_path}\\\" -c \\\"python\\\""' |> runtime.split_args |> resultm.get)
|> run Verbose
|> async.block_on_futures
|> resultm.unwrap'
|> sm'.deserialize
|> resultm.unwrap'
|> mapm.get ("command_result" |> sm'.to_std_string)
|> optionm'.unwrap
|> sm'.from_std_string
|> sm'.deserialize
|> resultm.unwrap'
|> fun result =>
    result
    |> mapm.get ("extension" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "py"
    result
    |> mapm.get ("output" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "-3"

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io futures rand rayon regex serde_json sha2

inl file_name = "test.dib"
inl code =
    "#!meta\n\n{\"kernelInfo\":{\"defaultKernelName\":\"fsharp\",\"items\":[]}}\n\n#!fsharp\n\n3 - 6\n"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
disposable |> use |> ignore
inl path = temp_dir </> file_name |> file_system.normalize_path

code
|> file_system.write_all_text path

get_command ()
|> runtime.command_get_matches_from ($'$"_ dib -lp {!path}"' |> runtime.split_args |> resultm.get)
|> run Verbose
|> async.block_on_futures
|> resultm.unwrap'
|> __assert sm'.contains Silent "<pre>-3"

$'$"{!path}.html"'
|> file_system.read_all_text
|> __assert sm'.contains Silent "\"cell-id=1\""

#!markdown

## tests

#!spiral

inl tests () =
    testing.run_tests {
        verify_app = get_command >> runtime.command_debug_assert
    }

#!markdown

## main

#!spiral

///! _

inl main (args : array_base string) =
    inl trace_state = get_trace_state_or_init None

    trace Debug
        fun () => "spiral.main"
        fun () => { args }

    inl command = get_command ()
    inl arg_matches = command |> runtime.command_get_matches

    inl trace_state_level = trace_state.level

    inl result =
        arg_matches
        |> run *trace_state_level
        |> async.block_on_futures
        |> resultm.unwrap'

    if *trace_state_level = Info
    then result |> console.write_line

    0i32

inl main () =
    $'let tests () = !tests ()' : ()
    $'let main args = !main args' : ()
