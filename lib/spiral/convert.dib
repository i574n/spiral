#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[{"name":"spiral"}]}}

#!markdown

# convert

#!spiral

///- --test static

open testing

#!markdown

## convert

#!markdown

### unativeint

#!spiral

nominal unativeint = $'unativeint'

#!markdown

### to''

#!spiral

inl to'' forall t u. (fn : t -> u) (x : t) : u =
    real
        typecase t * u with
        | ~x * ~x => x
        | int * int => conv `t `u x
        // | float * float => conv `t `u x
        // | int * float => conv `t `u x
        // | float * int => conv `t `u x
        // | char * bool => x = '1'
        // | bool * char => if x then '1' else '0'
        // | bool * _ => if x then 1 else 0
        | _ => fn x

#!markdown

### to'

#!spiral

inl to' forall t u. (fn : t -> option u) (x : t) : option u =
    real
        typecase t * u with
        | ~x * ~x => Some `u x
        | int * int => Some `u (conv `t `u x)
        | float * float => Some `u (conv `t `u x)
        | int * float => Some `u (conv `t `u x)
        | float * int => Some `u (conv `t `u x)
        | char * bool => Some `u (x = '1')
        | bool * char => Some `u (if x then '1' else '0')
        | bool * _ => Some `u (if x then 1 else 0)
        | _ => fn x

#!markdown

### to

#!spiral

inl to forall t u. (x : t) : u =
    real
        typecase t * u with
        | ~x * ~x => x : u
        | int * int => conv `t `u x
        | _ => $'!x ' : u

#!markdown

### convert_i32_base

#!spiral

inl convert_i32_base forall t. (base : i32) (x : t) : i32 =
    backend_switch {
        Gleam = fun () =>
            global "import gleam/int"
            inl (n : int), (err : int) =
                $'case int.base_parse(!x, !base) { Ok(n) -> ##(n, 0) Error(Nil) -> ##(0, 1) }'
            if err = 0
            then n |> Some
            else None
            |> optionm.value
        Lua = fun () => $'tonumber( !x, !base )' : i32
        Fsharp = fun () => $'System.Convert.ToInt32 (!x, !base)' : i32
        Python = fun () => $'int (!x, !base)' : i32
    }

#!markdown

### convert_i32

#!spiral

inl convert_i32 forall t. (x : t) : int =
    backend_switch {
        Gleam = fun () => x |> convert_i32_base 10 : int
        Lua = fun () => x |> convert_i32_base 10 : int
        Fsharp = fun () => $'System.Convert.ToInt32(!x)' : int
        Python = fun () => x |> convert_i32_base 10 : int
    }

#!markdown

### try_convert

#!spiral

inl try_convert forall t u. (x : t) : option u =
    x |> to' fun x =>
        backend_switch {
            Gleam = fun () =>
                if (real typecase u with int => true | _ => false) then
                    global "import gleam/int"
                    inl (n : int), (err : int) =
                        $'case int.parse(!x) { Ok(n) -> ##(n, 0) Error(Nil) -> ##(0, 1) }'
                    if err = 0
                    then n |> to |> Some
                    else None : _ u
                else x |> to |> Some
            Lua = fun () =>
                x |> to |> Some : _ u
            Fsharp = fun () =>
                resultm.from_try
                    fun () => $'!x |> `u '
                    eval
                |> resultm.ok
                : _ u
            Python = fun () =>
                resultm.from_try
                    fun () => $'`u(!x)'
                    eval
                |> resultm.ok
                : _ u
        }

#!spiral

///- --test
///> gleam
///> lua
///> fsharp
///> rust

3i32
|> try_convert
|> optionm.value
|> _assert_eq' (
    backend_switch {
        Gleam = fun () => ($'3' : unativeint) : unativeint
        Lua = fun () => ($'3' : unativeint) : unativeint
        Fsharp = fun () => ($'3 |> `unativeint ' : unativeint) : unativeint
        Python = fun () => ($'3' : unativeint) : unativeint
    } : unativeint
)

#!spiral

///- --test
///> gleam
///> fsharp
///> rust
///> cuda

"3"
|> try_convert
|> _assert_eq (3i32 |> Some)

"a"
|> try_convert
|> _assert_eq (None : _ int)

true
|> try_convert
|> _assert_eq (1i32 |> Some)

false
|> try_convert
|> _assert_eq (0i32 |> Some)

#!markdown

### convert

#!spiral

inl convert forall t u. (x : t) : u =
    x |> try_convert |> optionm.value

#!markdown

### unbox

#!spiral

inl unbox forall t u. (x : t) : u =
    backend_switch {
        Gleam = fun () => x |> to : u
        Lua = fun () => x |> to : u
        Fsharp = fun () => $'!x |> unbox<`u>' : u
        Python = fun () => x |> to : u
    }

#!markdown

### u8

#!spiral

inl u8 forall t. (x : t) : u8 =
    backend_switch {
        Gleam = fun () => x |> convert : u8
        Lua = fun () => x |> to : u8
        Fsharp = fun () => x |> $'uint8' : u8
        Python = fun () => x |> to : u8
    }

#!markdown

### u16

#!spiral

inl u16 forall t. (x : t) : u16 =
    backend_switch {
        Gleam = fun () => x |> convert : u16
        Lua = fun () => x |> to : u16
        Fsharp = fun () => x |> $'uint16' : u16
        Python = fun () => $'!x & 0xFFFF' : u16
    }

#!markdown

### u64

#!spiral

inl u64 forall t. (x : t) : u64 =
    backend_switch {
        Gleam = fun () => x |> convert : u64
        Lua = fun () => x |> to : u64
        Fsharp = fun () => x |> $'uint64' : u64
        Python = fun () => x |> to : u64
    }

#!markdown

### i32

#!spiral

inl i32 forall t. (x : t) : i32 =
    backend_switch {
        Gleam = fun () => x |> convert : i32
        Lua = fun () => x |> convert : i32
        Fsharp = fun () => x |> convert : i32
        Python = fun () => x |> convert : i32
    }

#!markdown

### i64

#!spiral

inl i64 forall t. (x : t) : i64 =
    backend_switch {
        Gleam = fun () => x |> convert : i64
        Lua = fun () => x |> to : i64
        Fsharp = fun () => x |> $'int64' : i64
        Python = fun () => x |> to : i64
    }

#!markdown

### f32

#!spiral

inl f32 forall t. (x : t) : f32 =
    backend_switch {
        Gleam = fun () => x |> convert : f32
        Lua = fun () => x |> to : f32
        Fsharp = fun () => x |> $'float32' : f32
        Python = fun () => x |> to : f32
    }

#!markdown

### f64

#!spiral

inl f64 forall t. (x : t) : f64 =
    backend_switch {
        Gleam = fun () => x |> convert : f64
        Lua = fun () => x |> to : f64
        Fsharp = fun () => x |> $'float' : f64
        Python = fun () => x |> to : f64
    }

#!markdown

### to_any

#!spiral

inl to_any forall t. (obj : t) : any =
    obj |> to

#!markdown

### (~:>) any

#!spiral

instance (~:>) any = to_any
