#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[{"name":"spiral"}]}}

#!markdown

# parsing

#!spiral

open sm'_operators

#!spiral

///- --test force

open testing

#!markdown

## fparsec

#!spiral

///- --test

#r @"../../../../../../../.nuget/packages/fparsec/2.0.0-beta2/lib/netstandard2.1/FParsec.dll"
#r @"../../../../../../../.nuget/packages/fparsec/2.0.0-beta2/lib/netstandard2.1/FParsecCS.dll"

///> _

()

#!spiral

///- --test force

nominal position_ = $'FParsec.Position'
nominal parser_error_ = $'FParsec.Error.ParserError'

nominal reply_ t = $'FParsec.Reply<`t>'

nominal char_stream_ t = $'FParsec.CharStream<`t>'

// nominal parser t u = char_stream u -> reply t
nominal parser_ t u = $'FParsec.Primitives.Parser<`t, `u>'

inl p_char_ forall t. (x : char) : parser_ char t =
    x |> $'FParsec.CharParsers.pchar'

inl p_string_ forall t. (x : string) : parser_ string t =
    x |> $'FParsec.CharParsers.pstring'

inl (>>.$) forall t u v. (a : parser_ t v) (b : parser_ u v) : parser_ u v =
    b |> $'FParsec.Primitives.(>>.)' a

inl (.>>$) forall t u v. (a : parser_ t v) (b : parser_ u v) : parser_ t v =
    b |> $'FParsec.Primitives.(.>>)' a

inl (.>>.$) forall t u v. (a : parser_ t v) (b : parser_ u v) : parser_ (pair t u) v =
    b |> $'FParsec.Primitives.(.>>.)' a

inl (>>%$) forall t u v. (a : parser_ t v) (b : u) : parser_ u v =
    b |> $'FParsec.Primitives.(>>%)' a

inl (>>=$) forall t u v. (a : parser_ t v) (b : t -> parser_ u v) : parser_ u v =
    b |> $'FParsec.Primitives.(>>=)' a

inl (|>>$) forall t u v. (a : parser_ t v) (b : t -> u) : parser_ u v =
    inl b = fun x => x |> b
    b |> $'FParsec.Primitives.(|>>)' a

inl any_char_ () : parser_ char _ =
    $'FParsec.CharParsers.anyChar'

inl any_string_ () : parser_ string _ =
    $'FParsec.CharParsers.anyString'

inl any_string__ (n : int) : parser_ string _ =
    n |> $'FParsec.CharParsers.anyString'

inl eof_ () : parser_ () _ =
    $'FParsec.CharParsers.eof'

inl spaces_ () : parser_ () () =
    $'FParsec.CharParsers.spaces'

inl spaces1_ () : parser_ () () =
    $'FParsec.CharParsers.spaces1'

inl (<|>$) forall t u. (a : parser_ t u) (b : parser_ t u) : parser_ t u =
    b |> $'FParsec.Primitives.(<|>)' a

inl many_satisfy_ forall t. (x : char -> bool) : parser_ string t =
    x |> $'FParsec.CharParsers.manySatisfy'

inl satisfy_ forall t. (x : char -> bool) : parser_ char t =
    x |> $'FParsec.CharParsers.satisfy'

inl none_of_ (x : list char) : parser_ char () =
    x
    |> listm'.box
    |> listm'.to_array'
    |> $'FParsec.CharParsers.noneOf'

inl any_of_ (x : list char) : parser_ char () =
    x
    |> listm'.box
    |> listm'.to_array'
    |> $'FParsec.CharParsers.anyOf'

inl skip_any_of_ (x : list char) : parser_ () () =
    x
    |> listm'.box
    |> listm'.to_array'
    |> $'FParsec.CharParsers.skipAnyOf'

inl between_ forall t u v x. (a : parser_ t x) (b : parser_ u x) (c : parser_ v x) : parser_ v x =
    c |> $'FParsec.Primitives.between' a b

inl many_chars_ forall t. (x : parser_ char t) : parser_ string t =
    x |> $'FParsec.CharParsers.manyChars'

inl many1_chars_ forall t. (x : parser_ char t) : parser_ string t =
    x |> $'FParsec.CharParsers.many1Chars'

inl many_strings_ forall t. (x : parser_ string t) : parser_ string t =
    x |> $'FParsec.CharParsers.manyStrings'

inl skip_any_string_ forall t. (n : int) : parser_ () t =
    n |> $'FParsec.CharParsers.skipAnyString'

inl many1_strings_ forall t. (x : parser_ string t) : parser_ string t =
    x |> $'FParsec.CharParsers.many1Strings'

inl opt_ forall t u. (a : parser_ t u) : parser_ (optionm'.option' t) u =
    a |> $'FParsec.Primitives.opt'

inl choice_ forall t u. (a : list (parser_ t u)) : parser_ t u =
    a
    |> listm'.box
    |> seq.of_list'
    |> $'FParsec.Primitives.choice'

inl delay_ forall t u. (fn : () -> parser_ t u) : parser_ t u =
    fn |> $'FParsec.Primitives.parse.Delay'

inl peek_ forall t u. (a : parser_ t u) : parser_ char u =
    $'!a.Peek ()'

inl not_followed_by_ forall t u. (a : parser_ t u) : parser_ () u =
    a |> $'FParsec.Primitives.notFollowedBy'

inl sep_by_ forall t u v. (a : parser_ t v) (b : parser_ u v) : parser_ (listm'.list' t) v =
    b |> $'FParsec.Primitives.sepBy' a

inl sep_by1_ forall t u v. (a : parser_ t v) (b : parser_ u v) : parser_ (listm'.list' t) v =
    b |> $'FParsec.Primitives.sepBy1' a

inl sep_end_by_ forall t u v. (a : parser_ t v) (b : parser_ u v) : parser_ (listm'.list' t) v =
    b |> $'FParsec.Primitives.sepEndBy' a

inl many_ forall t u. (a : parser_ t u) : parser_ (listm'.list' t) u =
    a |> $'FParsec.Primitives.many'

inl many1_ forall t u. (a : parser_ t u) : parser_ (listm'.list' t) u =
    a |> $'FParsec.Primitives.many1'

inl many1_satisfy_ forall t. (x : char -> bool) : parser_ string t =
    x |> $'FParsec.CharParsers.many1Satisfy'

nominal parser_result'_ t u = $'FParsec.CharParsers.ParserResult<`t, `u>'

inl run_ forall t. (parser : parser_ t ()) (x : string) : parser_result'_ t () =
    x |> $'FParsec.CharParsers.run' parser

union parser_result_ t u =
    | Success : t * u * position_
    | Failure : string * parser_error_ * u

inl parser_result_ forall t u. = function
    | Success (a, b, c) => $'`(parser_result'_ t u).Success (!a, !b, !c)' : parser_result'_ t u
    | Failure (a, b, c) => $'`(parser_result'_ t u).Failure (!a, !b, !c)' : parser_result'_ t u

inl parser_result'_ forall t u. (x : parser_result'_ t u) : parser_result_ t u =
    $'let mutable _!x = None '
    $'match !x with'
    $'| FParsec.CharParsers.Success (a, b, c) -> (' : ()
    $'(fun () ->'
    $'(fun () ->'
    (Success ((dyn $'a'), dyn $'b', dyn $'c') : _ t u) |> emit_unit
    $')'
    $'|> fun x -> x ()'
    $') () ) | FParsec.CharParsers.Failure (a, b, c) -> (' : ()
    $'(fun () ->'
    $'(fun () ->'
    (Failure ((dyn $'a'), dyn $'b', dyn $'c') : _ t u) |> emit_unit
    $')'
    $'|> fun x -> x ()'
    $') () )' : ()
    $'|> fun x -> _!x <- Some x'
    $'match _!x with Some x -> x | None -> failwith "??? / _!x=None"'

inl parse_ parser input : result _ _ =
    match input |> run_ parser |> parser_result'_ with
    | Success (result, b, c) => Ok (result, c)
    | Failure (error_msg, b, c) => Error (error_msg, b)

#!spiral

///- --test

inl split_args (args : string) : result (array_base (string * position_)) (string * parser_error_) =
    inl esc = [ '\\'; '`' ]
    inl quotes = [ '"' ]
    inl special = esc ++ quotes
    inl p_esc_char c =
        p_char_ c >>.$ any_char_ () |>>$ fun c' => $'$"{!c}{!c'}"'
    inl p_word = special |> none_of_ |>>$ sm'.obj_to_string
    inl p_plain = special ++ [ ' ' ] |> none_of_ |> many1_chars_
    inl p_text = p_word |> many1_strings_
    inl p_esc = esc |> listm.map p_esc_char |> choice_
    inl p_quoted = (p_word <|>$ p_esc) |> many_ |>>$ (seq.of_list' >> sm'.concat "")
    inl p_quoted_all = p_quoted |> between_ (p_char_ '"') (p_char_ '"')
    inl p_esc_root = (p_esc |>>$ (fun _ => "")) >>.$ (p_word |> many_) |>>$ (seq.of_list' >> sm'.concat "")
    inl p_content = p_plain <|>$ p_quoted_all <|>$ p_esc_root
    inl p_args = spaces1_ () |> sep_by_ p_content
    args
    |> parse_ p_args
    |> resultm.map fun (a', b') =>
        (
            (
                a'
                |> listm'.to_array'
                |> a
                |> am.map fun x => x, b'
                |> fun (a x : _ int _) => x
            )
        )

[
    "a b c",
    ;[ "a"; "b"; "c" ]

    "e f \"g h\" i",
    ;[ "e"; "f"; "g h"; "i" ]

    "\"j k\" \"l\" \"m\"",
    ;[ "j k"; "l"; "m" ]

    "s -t \"u \`\"v\`\" w\"",
    ;[ "s"; "-t"; "u \`\"v\`\" w" ]

    "n -o \"p \\\"q\\\" r\"",
    ;[ "n"; "-o"; "p \\\"q\\\" r" ]

    "r -s \"t \\\"u\\\"\"",
    ;[ "r"; "-s"; "t \\\"u\\\"" ]

    $'$"x -y \\\"$z -a \'(b=\\\\\\"c-id=)[a-fA-F0-9]{{8}}\', {{ \`$_[1] + \`$d++ }}\\\""',
    ;[ "x"; "-y"; "$z -a '(b=\\\"c-id=)[a-fA-F0-9]{8}', { `$_[1] + `$d++ }" ]

    "e -f \"$g -h '(i=`\"j-id=)[a-fA-F0-9]{8}', { `$_[1] + `$k++ }\"",
    ;[ "e"; "-f"; "$g -h '(i=`\"j-id=)[a-fA-F0-9]{8}', { `$_[1] + `$k++ }" ]

    $'$"--l \\\\\\"\'\'\' m \'\'\'\\\\\\" "',
    ;[ "--l"; "''' m '''" ]

    $'$"n --o --p q --r \\\"s:/t u/v.w\\\" --x \\\"y:/z.a\\\" --b c.d \\\"\\\\e{{f-g}}\\\" h.i \\\"j (k)\\\""',
    ;[ "n"; "--o"; "--p"; "q"; "--r"; "s:/t u/v.w"; "--x"; "y:/z.a"; "--b"; "c.d"; "\\e{f-g}"; "h.i"; "j (k)" ]

    $'\@$"l ""m n:\\o.p"""',
    ;[ "l"; "m n:\\o.p" ]
]
|> listm.rev
|> listm.map fun input, expected =>
    input
    |> split_args
    |> fun x =>
        try
            fun () =>
                ($'$"\ninput: {!input}"' : string)
                |> console.write_line
                x
                |> resultm.get
                |> am'.map_base fst
                |> _assert_eq' expected
                false
            fun ex =>
                ($'$"error / expected: %A{!expected} / ex: %A{!ex}"' : string)
                |> console.write_line
                Some true
        |> optionm.value
|> listm'.filter id
|> function
    | [] => ()
    | x => failwith $'$"{!x}"'

#!markdown

## parsing

#!markdown

### position

#!markdown

### range

#!spiral

type range =
    {
        from : int
        to : int
    }

#!spiral

type position =
    {
        line : int
        col : int
    }

#!markdown

### parser_state

#!spiral

nominal parser_state =
    {
        line_start : int
        position : position
        text_length : int
    }

#!markdown

### new_parser_state

#!spiral

inl new_parser_state (line_start : i32) (line : i32) (col : i32) (text_length : i32) =
    { line_start position = { line col }; text_length }

#!markdown

### new_parser_state\''

#!spiral

inl new_parser_state' text_length =
    new_parser_state 0 1 1 text_length |> parser_state

#!markdown

### parser

#!spiral

type parser t = string * int * parser_state -> result ((() -> t) * int * parser_state) (() -> string)

#!markdown

### slice

#!spiral

inl slice (start : int) (end : int) (t : string) : string =
    t
    |> sm'.range (am'.Start start) (am'.End fun _ => end)
    |> trace_format Verbose fun r =>
        "parsing.slice", { start end t_length = t |> sm'.length : int; r_length = r |> sm'.length : int }

#!markdown

### parse

#!spiral

inl parse forall t.
    (p : parser t)
    (input : string)
    (s : parser_state)
    : result ((() -> t) * (() -> string) * parser_state) (() -> string)
    =
    p (input, 0, s)
    |> resultm.map fun result, i, (parser_state s' as s) =>
        result,
        (fun () => input |> slice i s'.text_length),
        s

#!markdown

### update_char

#!spiral

inl update_char (parser_state s) (c : char) : parser_state =
    match c with
    | '\n' =>
        { s with
            line_start = s.line_start + s.position.col
            position = { line = s.position.line + 1; col = 1 }
        }
    | _ =>
        { s with
            position = { line = s.position.line; col = s.position.col + 1 }
        }
    |> parser_state
    |> trace_format Verbose fun r => "parsing.update_char", { c s r }

#!markdown

### update_span

#!spiral

inl update_span (input : string) (i : int) (len : int) (parser_state s) : parser_state =
    inl endi = i + len
    let rec 루프 (j : int) (last_nl : int) (count : int) =
        trace Verbose
            (fun () => "parsing.update_span / 루프")
            (fun () => { j last_nl count })
        if j >= endi
        then last_nl, count
        else
            match input |> sm'.index j with
            | '\n' => 루프 (j + 1) j (count + 1)
            | _ => 루프 (j + 1) last_nl count
    inl last_nl, n = 루프 i -1 0
    if n = 0
    then { s with position = { line = s.position.line; col = s.position.col + len } }
    else
        { s with
            line_start = last_nl + 1
            position =
                {
                    line = s.position.line + n
                    col = endi - last_nl
                }
            text_length = s.text_length
        }
    |> parser_state
    |> trace_format Verbose fun r =>
        "parsing.update_span", { i len endi last_nl n text_length = input |> sm'.length : int; s r }

#!markdown

### update

#!spiral

inl update t s =
    s
    |> update_span t 0 (t |> sm'.length)
    |> trace_format Verbose fun r => "parsing.update", { t s r }

#!markdown

### advance_while

#!spiral

inl advance_while (fn : char -> bool) (t : string) (i : int) (parser_state s' as s)
    : int * parser_state
    =
    if i >= s'.text_length
    then i, s
    else
        inl i' = i |> sm'.span_from fn t
        inl i' =
            if i' > s'.text_length
            then s'.text_length
            else i'
        inl consumed = i' - i
        if consumed = 0
        then i, s
        else i', s |> update_span t i consumed
    |> trace_format Verbose fun r =>
        "parsing.advance_while", { i t_length = t |> sm'.length : int; s r }

#!markdown

### run_parser

#!spiral

inl run_parser p input =
    input
    |> parse p
    |> fun run => run (new_parser_state' (input |> sm'.length))
    |> resultm.map fun a, b, s => a (), b (), s

#!markdown

### any_char

#!spiral

inl any_char () : parser char = fun t, i, (parser_state s' as s) =>
    if i >= s'.text_length then
        fun () => "parsing.any_char / unexpected end of t / " ++# ({ s } |> sm'.format)
        |> Error
    else
        inl c = t |> sm'.index i
        trace Verbose (fun () => "parsing.any_char") (fun () => { c s })
        Ok ((fun () => c), i + 1, c |> update_char s)
    |> trace_format Verbose fun r => "parsing.any_char", { i t_length = t |> sm'.length : int; s r }

#!spiral

///- --test

"abc"
|> run_parser (any_char ())
|> unwrap_format
|> _assert_eq #?*('a', "bc", new_parser_state 0 1 2 3)

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abc"
|> run_parser (any_char ())
|> unwrap_format
|> _assert_eq $$('a', "bc", new_parser_state 0 1 2 3)

#!spiral

///- --test

"abc"
|> parse_ (any_char_ ())
|> unwrap_format
|> _assert_eq' $$('a', ($'FParsec.Position (null, 0, 1, 2)' : position_))

#!markdown

### get_max_context

#!spiral

inl get_max_context () =
    80

#!markdown

### p_char

#!spiral

inl p_char (c : char) : parser char =
    fun input, i, (parser_state ({ line_start position = { line col } } as st) as s) =>
        trace Verbose (fun () => "parsing.p_char") (fun () => { c text_length = input |> sm'.length : int })
        if i >= st.text_length then
            fun () => "parsing.p_char / unexpected end of input / " ++# ({ c st } |> sm'.format)
            |> Error
        else
            inl got = input |> sm'.index i
            if got = c
            then Ok ((fun () => got), i + 1, got |> update_char s)
            else
                fun () =>
                    inl line_end = i |> sm'.span_from ((<>) '\n') input
                    inl end = (i + get_max_context ()) |> min line_end
                    inl line_slice = input |> slice line_start end
                    inl new_line =
                        inl n = line_slice |> sm'.length
                        if n > 0 && (line_slice |> sm'.index (n - 1i32)) = '\n' then "" else "\n"
                    inl pointer_line = (" " |> sm'.replicate (col - 1)) ++# "^"
                    "parsing.p_char / "
                    ++# ({ expected = c; line col } |> sm'.format)
                    ++# "\n" ++# line_slice
                    ++# new_line
                    ++# pointer_line ++# "\n"
                |> Error

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abc"
|> run_parser (p_char 'a')
|> unwrap_format
|> _assert_eq $$('a', "bc", new_parser_state 0 1 2 3)

#!spiral

///- --test

"abc"
|> parse_ (p_char_ 'a')
|> unwrap_format
|> _assert_eq' $$('a', ($'FParsec.Position (null, 0, 1, 2)' : position_))

#!markdown

### any_string

#!spiral

inl any_string length : parser string = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.any_string") (fun () => { text_length = input |> sm'.length : int })
    if st.text_length - i >= length
    then Ok ((fun () => input |> slice i (i + length)), i + length, s |> update_span input i length)
    else
        fun () => "parsing.any_string / unexpected end of input / " ++# ({ s } |> sm'.format)
        |> Error

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abcdef"
|> run_parser (any_string 3)
|> unwrap_format
|> _assert_eq $$("abc", "def", new_parser_state 0 1 4 6)

#!spiral

///- --test

"abcdef"
|> parse_ (any_string__ 3)
|> resultm.get
|> sm'.obj_to_string
|> _assert_eq' (("abc", ($'FParsec.Position (null, 0, 1, 4)' : position_)) |> sm'.obj_to_string)

#!markdown

### skip_any_string

#!spiral

inl skip_any_string length : parser () = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.skip_any_string") (fun () => { text_length = input |> sm'.length : int })
    if st.text_length - i >= length
    then Ok (id, i + length, s |> update_span input i length)
    else
        fun () => "parsing.skip_any_string / unexpected end of input / " ++# ({ s } |> sm'.format)
        |> Error

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abcdef"
|> run_parser (skip_any_string 3)
|> unwrap_format
|> _assert_eq $$((), "def", new_parser_state 0 1 4 6)

#!markdown

### skip_many

#!spiral

inl skip_many forall t. (a : parser t) : parser () = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.skip_many") (fun () => { text_length = input |> sm'.length : int })
    let rec 루프 (i : int) (s : parser_state) =
        match a (input, i, s) with
        | Error _ => Ok (id : () -> (), i, s)
        | Ok (_, j, s') =>
            if j <> i
            then s' |> 루프 j
            else
                fun () => "parsing.skip_many / inner parser consumed no input"
                |> Error
    s0 |> 루프 i0

#!spiral

///- --test

"sskkip_many"
|> run_parser (skip_many (p_char 's'))
|> unwrap_format
|> _assert_eq $$("kkip_many", new_parser_state 0 1 3 11)

#!markdown

### skip_many1

#!spiral

inl skip_many1 forall t. (a : parser t) : parser () = fun input, i, s =>
    trace Verbose (fun () => "parsing.skip_many1") (fun () => { text_length = input |> sm'.length : int })
    match a (input, i, s) with
    | Error e => e |> Error
    | Ok (_, j, s') =>
        if j <> i
        then skip_many a (input, j, s')
        else
            fun () => "parsing.skip_many1 / inner parser consumed no input"
            |> Error

#!spiral

///- --test

"skip_many1"
|> run_parser (skip_many1 (p_char 's'))
|> unwrap_format
|> _assert_eq $$("kip_many1", new_parser_state 0 1 2 10)

#!markdown

### (>>.)

#!spiral

inl (>>.) forall t u. (a : parser t) (b : parser u) : parser u = fun input, i, s =>
    trace Verbose (fun () => "parsing.(>>.)") (fun () => { text_length = input |> sm'.length : int })
    match a (input, i, s) with
    | Ok (_, i', s') => b (input, i', s')
    | Error e => e |> Error

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abc\ndef\nghi"
|> run_parser (skip_any_string 5 >>. p_char 'a')
|> resultm.map_error eval
|> _assert_eq (Error "parsing.p_char / { expected = a; line = 2; col = 2 }\ndef\n ^\n")

#!markdown

### (.>>)

#!spiral

inl (.>>) forall t u. (a : parser t) (b : parser u) : parser t = fun input, i, s =>
    trace Verbose (fun () => "parsing.(.>>)") (fun () => { text_length = input |> sm'.length : int })
    match a (input, i, s) with
    | Error e => e |> Error
    | Ok (ra, i', s') =>
        b (input, i', s')
        |> resultm.map fun _, i'', s'' =>
            ra, i'', s''

#!markdown

### (.>>.)

#!spiral

inl (.>>.) forall t u. (a : parser t) (b : parser u) : parser ((() -> t) * (() -> u)) = fun input, i, s =>
    trace Verbose (fun () => "parsing.(.>>.)") (fun () => { text_length = input |> sm'.length : int })
    match a (input, i, s) with
    | Error e => e |> Error
    | Ok (ra, i', s') =>
        b (input, i', s')
        |> resultm.map fun rb, i'', s'' =>
            (fun () => ra, rb), i'', s''

#!markdown

### (>>%)

#!spiral

inl (>>%) forall t u. (a : parser t) (b : u) : parser u =
    a >> resultm.map fun _, i', s' =>
        (fun () => b), i', s'

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abc"
|> run_parser (p_char 'a' >>. p_char 'b')
|> unwrap_format
|> _assert_eq $$('b', "c", new_parser_state 0 1 3 3)

#!spiral

///- --test

"abc"
|> parse_ (p_char_ 'a' >>.$ p_char_ 'b')
|> resultm.get
|> sm'.obj_to_string
|> _assert_eq' (('b', ($'FParsec.Position (null, 0, 1, 3)' : position_)) |> sm'.obj_to_string)

#!spiral

///- --test

"abc\ndef\nghi"
|> parse_ (skip_any_string_ 5 >>.$ p_char_ 'a')
|> resultm.unwrap_err
|> sm'.obj_to_string
|> sm'.replace "\r\n" "\n"
|> _assert_eq "(Error in Ln: 2 Col: 2\ndef\n ^\nExpecting: 'a'\n, Error in Ln: 2 Col: 2\nExpecting: 'a'\n)"

#!markdown

### none_of

#!spiral

inl none_of (chars : list char) : parser char = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.none_of") (fun () => { chars text_length = input |> sm'.length : int })
    inl chars' () =
        chars |> listm'.box |> listm'.to_array' |> sm'.format
    if i >= st.text_length then
        fun () => "parsing.none_of / unexpected end of input / " ++# ({ chars' = chars' (); s } |> sm'.format)
        |> Error
    else
        inl ch = input |> sm'.index i
        if chars |> listm'.exists' ((=) ch) |> not
        then Ok ((fun () => ch), i + 1, ch |> update_char s)
        else
            fun () =>
                "parsing.none_of / unexpected char / "
                ++# ({ first_char = ch; chars' = chars' (); s } |> sm'.format)
            |> Error

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abc"
|> run_parser (none_of ['a'; 'b'; 'c'])
|> resultm.map_error eval
|> _assert_eq (
    backend_switch {
        Gleam = fun () =>
            "parsing.none_of / unexpected char / "
            ++# "{ first_char = a; chars' = [\"a\", \"b\", \"c\"]; s = #(0, 1, 1, 3) }"
        Fsharp = fun () =>
            run_target function
            | TypeScript _ => fun () =>
                join
                    "parsing.none_of / unexpected char / "
                    ++# "{ first_char = a; chars' = a,b,c; s = 0,1,1,3 }"
            | _ => fun () =>
                join
                    "parsing.none_of / unexpected char / "
                    ++# "{ first_char = a; chars' = [|'a'; 'b'; 'c'|]; s = struct (0, 1, 1, 3) }"
        Python = fun () =>
            "parsing.none_of / unexpected char / "
            ++# "{ first_char = a; chars' = ['a' 'b' 'c']; s = (0, 1, 1, 3) }"
    }
    |> Error
)

"def"
|> run_parser (none_of ['a'; 'b'; 'c'])
|> unwrap_format
|> _assert_eq $$('d', "ef", new_parser_state 0 1 2 3)

#!spiral

///- --test

"abc"
|> parse_ (none_of_ ['a'; 'b'; 'c'])
|> resultm.unwrap_err
|> sm'.obj_to_string
|> sm'.replace "\r\n" "\n"
|> _assert_eq ($'"(Error in Ln: 1 Col: 1\nabc\n^\nExpecting: any char not in ‘abc’\n, Error in Ln: 1 Col: 1\nExpecting: any char not in ‘abc’\n)"')

"def"
|> parse_ (none_of_ ['a'; 'b'; 'c'])
|> resultm.get
|> sm'.obj_to_string
|> _assert_eq' ($('d', ($'FParsec.Position (null, 0, 1, 2)' : position_)))

#!markdown

### (<|>)

#!spiral

inl (<|>) forall t. (a : parser t) (b : parser t) : parser t = fun input, i, s =>
    trace Verbose (fun () => "parsing.(<|>)") (fun () => { text_length = input |> sm'.length : int })
    match a (input, i, s) with
    | Ok _ as r => r
    | Error _ => b (input, i, s)

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abc"
|> run_parser (p_char 'a' <|> p_char 'b')
|> unwrap_format
|> _assert_eq $$('a', "bc", new_parser_state 0 1 2 3)

"cba"
|> run_parser (p_char 'a' <|> p_char 'b')
|> resultm.map_error eval
|> _assert_eq (Error "parsing.p_char / { expected = b; line = 1; col = 1 }\ncba\n^\n")

#!markdown

### (|>>)

#!spiral

inl (|>>) p f : parser _ =
    p >> resultm.map fun r, i', s' =>
        f r, i', s'

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"abc"
|> run_parser (p_char 'a' |>> fun c => fun () => c () |> sm'.char_to_upper)
|> unwrap_format
|> _assert_eq $$('A', "bc", new_parser_state 0 1 2 3)

#!markdown

### many

#!spiral

inl many forall b c.
    (p : _ * _ * _ -> _ ((() -> b) * _ * _) c)
    : parser (list _)
    =
    fun input, i0, s0 =>
        trace Verbose (fun () => "parsing.many") (fun () => { text_length = input |> sm'.length : int })
        let rec 루프 (acc : list b) (i : int) (s : parser_state)
            : result ((() -> list b) * int * parser_state) _
            =
            match p (input, i, s) with
            | Error _ => Ok ((fun () => acc |> listm.rev), i, s)
            | Ok (x, i', s') when i' > i => s' |> 루프 (x () :: acc) i'
            | Ok _ =>
                fun () => "parsing.many / inner parser succeeded without consuming input"
                |> Error
        s0 |> 루프 [] i0

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"aaabbc"
|> run_parser (many (p_char 'a' <|> p_char 'b'))
|> unwrap_format
|> _assert_eq $$(['a'; 'a'; 'a'; 'b'; 'b'], "c", new_parser_state 0 1 6 6)

#!markdown

### many1_chars

#!spiral

inl many1_chars (p : parser char) : parser string = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.many1_chars") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i0, s0) with
    | Error e => e |> Error
    | Ok (_, i1, s1) =>
        let rec 루프 (i : int) (s : parser_state) : result ((() -> string) * int * parser_state) _ =
            match p (input, i, s) with
            | Error _ => Ok ((fun () => input |> slice i0 i), i, s)
            | Ok (_, i', s') =>
                if i' <> i
                then s' |> 루프 i'
                else
                    fun () => "parsing.many1_chars / inner parser succeeded without consuming input"
                    |> Error
        s1 |> 루프 i1

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"aaabbc"
|> run_parser (many1_chars (p_char 'a' <|> p_char 'b'))
|> unwrap_format
|> _assert_eq $$("aaabb", "c", new_parser_state 0 1 6 6)

#!markdown

### many_chars

#!spiral

inl many_chars (p : parser char) : parser string = fun input, i, s =>
    trace Verbose (fun () => "parsing.many_chars") (fun () => { text_length = input |> sm'.length : int })
    match many1_chars p (input, i, s) with
    | Ok (res, i', s') => Ok (res, i', s')
    | Error _ => Ok ((fun () => ""), i, s)

#!markdown

### many_chars_till

#!spiral

inl many_chars_till (p : parser char) (end_p : parser _) = fun input, i0, (parser_state st as s0) =>
    trace Verbose (fun () => "parsing.many_chars_till") (fun () => { text_length = input |> sm'.length : int })
    let rec 루프 (i : int) (s : parser_state) : result ((() -> string) * int * parser_state) (() -> string) =
        if i >= st.text_length
        then Ok ((fun () => if i > i0 then input |> slice i0 i else ""), i, s)
        else
            inl j, s' = s |> advance_while (fun c => c <> '\n') input i
            if j >= st.text_length
            then Ok ((fun () => if j > i0 then input |> slice i0 j else ""), j, s')
            else
                match end_p (input, j, s') with
                | Ok _ => Ok ((fun () => if j > i0 then input |> slice i0 j else ""), j, s')
                | Error _ =>
                    match p (input, j, s') with
                    | Error _ => Ok ((fun () => if j > i0 then input |> slice i0 j else ""), j, s')
                    | Ok (_, j', s'') when j' > j => s'' |> 루프 j'
                    | Ok _ =>
                        fun () => "parsing.many_chars_till / inner parser succeeded without consuming input"
                        |> Error
    s0 |> 루프 i0

#!markdown

### many1

#!spiral

inl many1 (p : parser _) : parser (list _) = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.many1") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i0, s0) with
    | Error e => e |> Error
    | Ok (first, i1, s1) =>
        let rec 루프 acc (i : int) s : result ((() -> list _) * int * parser_state) _ =
            match p (input, i, s) with
            | Error _ => Ok ((fun () => acc |> listm.rev), i, s)
            | Ok (x, i', s') when i' > i => s' |> 루프 (x () :: acc) i'
            | Ok _ =>
                fun () => "parsing.many1 / inner parser succeeded without consuming input"
                |> Error
        s1 |> 루프 [ first () ] i1

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"aaabbc"
|> run_parser (many1 (p_char 'a' <|> p_char 'b'))
|> unwrap_format
|> _assert_eq $$([ 'a'; 'a'; 'a'; 'b'; 'b' ], "c", new_parser_state 0 1 6 6)

"bcc"
|> run_parser (many1 (p_char 'a' <|> p_char 'b'))
|> unwrap_format
|> _assert_eq $$([ 'b' ], "cc", new_parser_state 0 1 2 3)

"cba"
|> run_parser (many1 (p_char 'a' <|> p_char 'b'))
|> resultm.map_error eval
|> _assert_eq (Error "parsing.p_char / { expected = b; line = 1; col = 1 }\ncba\n^\n")

#!markdown

### many1_strings

#!spiral

inl many1_strings (p : parser _) : parser string = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.many1_strings") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i0, s0) with
    | Error e => e |> Error
    | Ok (r0, i1, s1) =>
        let rec 루프 (acc : list string) (i : int) s : result ((() -> string) * int * _) _ =
            match p (input, i, s) with
            | Error _ => Ok ((fun () => acc |> listm.rev |> sm'.concat_list ""), i, s)
            | Ok (r, i', s') when i' > i => s' |> 루프 (#?(r ()) :: acc) i'
            | Ok _ =>
                fun () => "parsing.many1_strings / inner parser succeeded without consuming input"
                |> Error
        s1 |> 루프 [ #?(r0 ()) ] i1

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"aaabbc"
|> run_parser (many1_strings (p_char 'a' <|> p_char 'b'))
|> unwrap_format
|> _assert_eq $$("aaabb", "c", new_parser_state 0 1 6 6)

#!markdown

### many_strings

#!spiral

inl many_strings (p : parser _) : parser string = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.many_strings") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i0, s0) with
    | Error _ => Ok ((fun () => ""), i0, s0)
    | Ok (r0, i1, s1) when i1 = i0 =>
        fun () => "parsing.many_strings / first inner parser consumed no input"
        |> Error
    | Ok (r0, i1, s1) =>
        let rec 루프 (acc : list string) (i : int) s : result ((() -> string) * int * _) _ =
            match p (input, i, s) with
            | Error _ => Ok ((fun () => #?(r0 ()) :: (acc |> listm.rev) |> sm'.concat_list ""), i, s)
            | Ok (r, i', s') when i' > i => s' |> 루프 (#?(r ()) :: acc) i'
            | Ok _ =>
                fun () => "parsing.many_strings / inner parser succeeded without consuming input"
                |> Error
        s1 |> 루프 [] i1

#!markdown

### choice

#!spiral

inl choice forall t. parsers : parser t = fun input, i, s =>
    trace Verbose (fun () => "parsing.choice") (fun () => { text_length = input |> sm'.length : int })
    let rec 루프 = function
        | [] =>
            fun () => "parsing.choice / no parsers succeeded"
            |> Error
        | (p : _ -> _ ((() -> t) * int * parser_state) _) :: ps =>
            match p (input, i, s) with
            | Ok _ as r => r
            | Error _ => ps |> 루프
    parsers |> 루프

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"bca"
|> run_parser (choice [ p_char 'a'; p_char 'b'; p_char 'c' ])
|> unwrap_format
|> _assert_eq $$('b', "ca", new_parser_state 0 1 2 3)

"cba"
|> run_parser (choice [ p_char 'a'; p_char 'b'; p_char 'c' ])
|> unwrap_format
|> _assert_eq $$('c', "ba", new_parser_state 0 1 2 3)

#!markdown

### between

#!spiral

inl between p_open p_close p_content : parser _ = fun input, i, s =>
    trace Verbose (fun () => "parsing.between") (fun () => { text_length = input |> sm'.length : int })
    match p_open (input, i, s) with
    | Ok (_, i', s') =>
        match p_content (input, i', s') with
        | Ok (result, i'', s'') =>
            match p_close (input, i'', s'') with
            | Ok (_, i''', s''') => Ok (result, i''', s''')
            | Error e =>
                fun () =>
                    inl total_len = input |> sm'.length
                    inl end' = (i' + get_max_context ()) |> min total_len
                    inl end'' = (i'' + get_max_context ()) |> min total_len
                    inl rest' = input |> slice i' end'
                    inl rest'' = input |> slice i'' end''
                    "parsing.between / expected closing delimiter / "
                    ++# ({ e input rest' rest'' } |> sm'.format)
                |> Error
        | Error _ =>
            match p_close (input, i', s') with
            | Ok (_, i''', s''') => Ok ((fun () => ""), i''', s''')
            | Error _ =>
                fun () =>
                    inl total_len = input |> sm'.length
                    inl end' = (i' + get_max_context ()) |> min total_len
                    inl rest' = input |> slice i' end'
                    "parsing.between / expected content or closing delimiter / "
                    ++# ({ rest' } |> sm'.format)
                |> Error
    | Error e => e |> Error

#!spiral

///- --test

"[aaabb"
|> parse_ (between_ (p_char_ '[') (p_char_ ']') (many1_chars_ (p_char_ 'a' <|>$ p_char_ 'b')))
|> resultm.unwrap_err
|> sm'.format_debug

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"[aaabb]"
|> run_parser (between (p_char '[') (p_char ']') (many1_chars (p_char 'a' <|> p_char 'b')))
|> unwrap_format
|> _assert_eq $$("aaabb", "", new_parser_state 0 1 8 7)

"[aaabb"
|> run_parser (between (p_char '[') (p_char ']') (many1_chars (p_char 'a' <|> p_char 'b')))
|> resultm.map_error eval
|> resultm.unwrap_err
|> sm'.format_debug
|> _assert_eq (
    "parsing.between / expected closing delimiter / "
    ++# "{ e = parsing.p_char / unexpected end of input / { c = ]; "
    ++# "st = " ++# ((new_parser_state 0 1 7 6) |> sm'.format) ++# " }; "
    ++# "input = [aaabb; rest' = aaabb; rest'' =  }"
)

#!markdown

### sep_by

#!spiral

inl sep_by forall b. p sep : parser (list b) = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.sep_by") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i0, s0) with
    | Error _ => Ok ((fun () => []), i0, s0)
    | Ok (first, i1, s1) =>
        let rec 루프 (acc : list b) (i : int) s : result ((() -> list b) * int * parser_state) _ =
            match sep (input, i, s) with
            | Error _ => Ok ((fun () => acc |> listm.rev), i, s)
            | Ok (_, j, s') =>
                if j = i then
                    fun () => "parsing.sep_by / separator consumed no input"
                    |> Error
                else
                    match p (input, j, s') with
                    | Ok (x, k, s'') => s'' |> 루프 (x () :: acc) k
                    | Error _ => Ok ((fun () => acc |> listm.rev), i, s)
        s1 |> 루프 [ first () ] i1

#!markdown

### sep_end_by

#!spiral

inl sep_end_by forall b. p sep : parser (list b) = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.sep_end_by") (fun () => { text_length = input |> sm'.length : int })
    let rec 루프 acc i s =
        match p (input, i, s) with
        | Error _ => Ok ((fun () => acc |> listm.rev), i, s)
        | Ok (x, j, s1) =>
            if j = i then
                fun () => "parsing.sep_end_by / element parser consumed no input"
                |> Error
            else
                inl acc' = x () :: acc
                match sep (input, j, s1) with
                | Error _ => Ok ((fun () => acc' |> listm.rev), j, s1)
                | Ok (_, k, s'') =>
                    if k <> j
                    then s'' |> 루프 acc' k
                    else
                        fun () => "parsing.sep_end_by / separator consumed no input"
                        |> Error
    s0 |> 루프 [] i0

#!spiral

///- --test

"sep_end_by"
|> run_parser (sep_end_by (p_char 's' <|> p_char 'e') (p_char 'e'))
|> unwrap_format
|> _assert_eq $$([ 's' ], "p_end_by", new_parser_state 0 1 3 10)

#!markdown

### is_space

#!spiral

inl is_space c =
    c = ' ' || c = '\t' || c = '\r'

#!markdown

### spaces1

#!spiral

inl spaces1 () : parser () = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.spaces1") (fun () => { text_length = input |> sm'.length : int })
    inl j, s' = s |> advance_while is_space input i
    if j <> i
    then Ok (id, j, s')
    else
        fun () =>
            inl preview_end = (i + get_max_context ()) |> min st.text_length
            "parsing.spaces1 / expected at least one space / "
            ++# ({ rest = input |> slice i preview_end } |> sm'.format)
        |> Error

#!markdown

### spaces

#!spiral

inl spaces () : parser () = fun input, i, s =>
    inl j, s' = s |> advance_while is_space input i
    Ok (id, j, s')

#!markdown

### p_digit

#!spiral

inl p_digit () : parser char = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.p_digit") (fun () => { text_length = input |> sm'.length : int })
    if i >= st.text_length then
        fun () => "parsing.p_digit / unexpected end of input / " ++# ({ s } |> sm'.format)
        |> Error
    else
        match input |> sm'.index i with
        | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' as c =>
            Ok ((fun () => c), i + 1, c |> update_char s)
        | c =>
            fun () => "parsing.p_digit / unexpected char / " ++# ({ c } |> sm'.format)
            |> Error

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"1 2 3"
|> run_parser (sep_by (p_digit ()) (spaces1 ()))
|> unwrap_format
|> _assert_eq $$([ '1'; '2'; '3' ], "", new_parser_state 0 1 6 5)

#!spiral

///- --test
///> gleam
///> fsharp
///> cuda
///> typescript

"1 a 2"
|> run_parser (sep_by (p_digit ()) (spaces1 ()))
|> unwrap_format
|> _assert_eq $$([ '1' ], " a 2", new_parser_state 0 1 2 5)

#!markdown

### opt

#!spiral

inl opt p : parser (option _) = fun input, i, s =>
    trace Verbose (fun () => "parsing.opt") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i, s) with
    | Ok (result, i', s') => Ok ((fun () => result |> Some), i', s')
    | Error _ => Ok ((fun () => None), i, s)

#!markdown

### rest_of_line

#!spiral

inl rest_of_line () : parser string = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.rest_of_line") (fun () => { text_length = input |> sm'.length : int })
    inl j, s' = s0 |> advance_while ((<>) '\n') input i0
    Ok ((fun () => input |> slice i0 j), j, s')

#!markdown

### eof

#!spiral

inl eof () : parser () = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.eof") (fun () => { text_length = input |> sm'.length : int })
    if st.text_length = i
    then Ok (id, i, s)
    else
        fun () =>
            "parsing.eof / expected end of input / "
            ++# ({ rest = input |> slice i st.text_length } |> sm'.format)
        |> Error

#!markdown

### p_string

#!spiral

inl p_string (str : string) : parser string = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.p_string") (fun () => { text_length = input |> sm'.length : int })
    inl len = str |> sm'.length
    if st.text_length - i < len then
        fun () => "parsing.p_string / unexpected end of input / " ++# ({ expected = str; s } |> sm'.format)
        |> Error
    else
        let rec eq k =
            if k >= len
            then true
            else input |> sm'.index (i + k) = str |> sm'.index k && eq (k + 1)
        if eq 0
        then Ok ((fun () => input |> slice i (i + len)), i + len, s |> update_span input i len)
        else
            fun () =>
                inl preview_end = (i + get_max_context ()) |> min st.text_length
                inl rest = input |> slice i preview_end
                inl got = input |> slice i (i + len)
                "parsing.p_string / unexpected string / "
                ++# ({ expected = str; got rest s } |> sm'.format)
            |> Error

#!spiral

///- --test

"hello world"
|> run_parser (p_string "hello")
|> unwrap_format
|> _assert_eq $$("hello", " world", new_parser_state 0 1 6 11)

#!markdown

### new_line

#!spiral

inl new_line () : parser char = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.new_line") (fun () => { text_length = input |> sm'.length : int })
    if i >= st.text_length then
        fun () => "parsing.new_line / unexpected end of input / " ++# ({ s } |> sm'.format)
        |> Error
    else
        inl c = input |> sm'.index i
        if c = '\n'
        then Ok ((fun () => c), i + 1, c |> update_char s)
        else
            fun () =>
                inl preview_end = (i + get_max_context ()) |> min st.text_length
                inl rest = input |> slice i preview_end
                "parsing.new_line / expected new line char / "
                ++# ({ first_char = c; rest s } |> sm'.format)
            |> Error

#!spiral

///- --test

"hello\nworld"
|> run_parser (many_chars_till (any_char ()) (new_line ()))
|> unwrap_format
|> _assert_eq $$("hello", "\nworld", new_parser_state 0 1 6 11)

#!markdown

### many_till

#!spiral

inl many_till forall b c. (p : parser b) (end_p : parser c) : parser _ = fun input, i0, s0 =>
    trace Verbose (fun () => "parsing.many_till") (fun () => { text_length = input |> sm'.length : int })
    let rec 루프 (acc : list b) (i : int) s : result (_ * int * parser_state) _ =
        trace Verbose
            (fun () => "parsing.many_till / loop")
            (fun () => { i acc_len = acc |> listm.length : int })
        match end_p (input, i, s) with
        | Ok (_, j, s') => Ok ((fun () => acc |> listm.rev), j, s')
        | Error _ =>
            match p (input, i, s) with
            | Ok (x, i', s') =>
                if i' <> i
                then s' |> 루프 (x () :: acc) i'
                else
                    fun () => "parsing.many_till / inner parser succeeded without consuming input"
                    |> Error
            | Error e => e |> Error
    s0 |> 루프 [] i0

#!spiral

///- --test

"hello\nworld"
|> run_parser (many_till (any_char ()) (new_line ()))
|> unwrap_format
|> _assert_eq $$(['h'; 'e'; 'l'; 'l'; 'o'], "world", new_parser_state 6 2 1 11)

#!markdown

### p_return

#!spiral

inl p_return forall t. (x : t) : parser t = fun input, i, s =>
    trace Verbose (fun () => "parsing.p_return") (fun () => { text_length = input |> sm'.length : int })
    Ok ((fun () => x), i, s)

#!spiral

///- --test

"abc"
|> run_parser (p_return 42i32)
|> unwrap_format
|> _assert_eq $$(42i32, "abc", new_parser_state 0 1 1 3)

#!markdown

### attempt

#!spiral

inl attempt forall t. (p : parser t) : parser t = fun input, i, s =>
    trace Verbose (fun () => "parsing.attempt") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i, s) with
    | Ok (r, i', s') => Ok (r, i', s')
    | Error e => e |> Error

#!spiral

///- --test

"aabbcc"
|> run_parser (attempt (p_char 'a' >>. p_char 'a' >>. p_char 'b' >>. p_char 'c'))
|> resultm.map_error eval
|> _assert_eq (Error "parsing.p_char / { expected = c; line = 1; col = 4 }\naabbcc\n   ^\n")

#!markdown

### look_ahead

#!spiral

inl look_ahead (p : parser _) : parser _ = fun input, i, s =>
    trace Verbose (fun () => "parsing.look_ahead") (fun () => { text_length = input |> sm'.length : int })
    match p (input, i, s) with
    | Ok (x, _, _) => Ok (x, i, s)
    | Error e => e |> Error

#!spiral

///- --test

"123"
|> run_parser (look_ahead (many1_chars (p_digit ())))
|> unwrap_format
|> _assert_eq $$("123", "123", new_parser_state 0 1 1 3)

#!markdown

### pipe2

#!spiral

inl pipe2 forall a b c. (p1 : parser a) (p2 : parser b) (f : ((() -> a) * (() -> b)) -> c) : parser c =
    p1 .>>. p2 |>> fun r => fun () =>
        trace Verbose (fun () => "parsing.pipe2") (fun () => {})
        r () |> f

#!spiral

///- --test

"pipe2"
|> run_parser (pipe2 (p_string "pipe") (spaces () >>. p_string "2") (fun a, b => a () ++# b ()))
|> unwrap_format
|> _assert_eq $$("pipe2", "", new_parser_state 0 1 6 5)

#!markdown

### new_lines

#!spiral

inl new_lines () : parser () = fun input, i, s =>
    trace Verbose (fun () => "parsing.new_lines") (fun () => { text_length = input |> sm'.length : int })
    inl j, s' = s |> advance_while ((=) '\n') input i
    Ok (id, j, s')

#!spiral

///- --test

"\n\nline1\nline2\n\nline4"
|> run_parser (many_till (any_char ()) (new_lines ()))
|> unwrap_format
|> _assert_eq $$(([] : _ char), "line1\nline2\n\nline4", new_parser_state 2 3 1 20)

#!markdown

### new_lines1

#!spiral

inl new_lines1 () : parser () = fun input, i, (parser_state st as s) =>
    trace Verbose (fun () => "parsing.new_lines1") (fun () => { text_length = input |> sm'.length : int })
    inl j, s' = s |> advance_while ((=) '\n') input i
    if j <> i
    then Ok (id, j, s')
    else
        fun () =>
            inl preview_end = (i + get_max_context ()) |> min st.text_length
            "parsing.new_lines1 / expected at least one new line / "
            ++# ({ rest = input |> slice i preview_end } |> sm'.format)
        |> Error

#!spiral

///- --test

"\n\n\n"
|> run_parser (new_lines ())
|> unwrap_format
|> _assert_eq $$("", new_parser_state 3 4 1 3)
