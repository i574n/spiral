#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[{"name":"spiral"}]}}

#!markdown

# runtime

#!spiral

open rust
open rust_operators
open sm'_operators

#!spiral

//// test

open testing
open file_system_operators

#!markdown

## runtime

#!markdown

### split_args

#!spiral

let split_args (args : string) : result (array_base string) string =
    open parsing
    inl esc = [ '\\'; '`' ]
    inl quotes = [ '"' ]
    inl special = esc ++ quotes
    inl p_esc_char c =
        p_char c >>. any_char () |>> fun c' => $c ++# $c'
    inl p_word = special |> none_of |>> sm'.obj_to_string
    inl p_plain = special ++ [ ' ' ] |> none_of |> many1_chars
    inl p_text = p_word |> many1_strings
    inl p_esc = esc |> listm.map p_esc_char |> choice
    inl p_quoted = (p_word <|> p_esc) |> many |>> sm'.concat_list ""
    inl p_quoted_all = p_quoted |> between (p_char '"') (p_char '"')
    inl p_esc_root = p_esc >>% "" >>. (p_word |> many) |>> sm'.concat_list ""
    inl p_content = p_plain <|> p_quoted_all <|> p_esc_root
    inl p_args = spaces1 () |> sep_by p_content
    args
    |> run_parser p_args
    |> resultm.map (fst >> listm'.box >> listm'.to_array')

#!spiral

//// test
///! gleam
///! fsharp
///! cuda
///! rust
///! typescript
///! python

[
    "a b c",
    ;[ "a"; "b"; "c" ]

    "e f \"g h\" i",
    ;[ "e"; "f"; "g h"; "i" ]

    "\"j k\" \"l\" \"m\"",
    ;[ "j k"; "l"; "m" ]

    "s -t \"u \`\"v\`\" w\"",
    ;[ "s"; "-t"; "u \`\"v\`\" w" ]

    "n -o \"p \\\"q\\\" r\"",
    ;[ "n"; "-o"; "p \\\"q\\\" r" ]

    "r -s \"t \\\"u\\\"\"",
    ;[ "r"; "-s"; "t \\\"u\\\"" ]

    $'"x -y \\\"$z -a \'(b=\\\\\\"c-id=)[a-fA-F0-9]{8}\', { \`$_[1] + \`$d++ }\\\""',
    ;[ "x"; "-y"; "$z -a '(b=\\\"c-id=)[a-fA-F0-9]{8}', { `$_[1] + `$d++ }" ]

    "e -f \"$g -h '(i=`\"j-id=)[a-fA-F0-9]{8}', { `$_[1] + `$k++ }\"",
    ;[ "e"; "-f"; "$g -h '(i=`\"j-id=)[a-fA-F0-9]{8}', { `$_[1] + `$k++ }" ]

    $'"--l \\\\\\"\'\'\' m \'\'\'\\\\\\" "',
    ;[ "--l"; "''' m '''" ]

    $'"n --o --p q --r \\\"s:/t u/v.w\\\" --x \\\"y:/z.a\\\" --b c.d \\\"\\\\e{f-g}\\\" h.i \\\"j (k)\\\""',
    ;[ "n"; "--o"; "--p"; "q"; "--r"; "s:/t u/v.w"; "--x"; "y:/z.a"; "--b"; "c.d"; "\\e{f-g}"; "h.i"; "j (k)" ]

    $'"l \\\"m n:\\\\o.p\\\""',
    ;[ "l"; "m n:\\o.p" ]
]
|> _assert_fn split_args

#!markdown

### split_command

#!spiral

let split_command (command : string) : result (string * option string) string =
    open parsing
    inl quotes = [ '"'; '\'' ]
    inl p_quoted_char = quotes |> listm.map p_char |> choice
    inl normalize = function '\\' => '/' | c => c
    inl p_quoted = quotes |> none_of |>> normalize |> many_chars |> between p_quoted_char p_quoted_char
    inl p_unquoted = quotes ++ [ ' ' ] |> none_of |>> normalize |> many1_chars
    inl p_path = p_quoted <|> p_unquoted <|> eof () >>% "" .>> spaces ()
    inl p_args = p_char ' ' |> opt >>. (any_char () |> many1_chars)
    inl p_command = p_path .>>. (p_args |> opt)
    command
    |> run_parser p_command
    |> resultm.map fst

#!spiral

//// test
///! gleam
///! fsharp
///! cuda
///! rust
///! typescript
///! python

[
    "",
    ("", None)

    "/a/b/c",
    ("/a/b/c", None)

    "d e.f",
    ("d", Some "e.f")

    "..\\..\\g.h i.j k.l",
    ("../../g.h", Some "i.j k.l")

    "m:\\n\\o.p \"q.r s.t\"",
    ("m:/n/o.p", Some "\"q.r s.t\"")

    "\"..\\..\\u v\\w.x\" \"y z.a\" b.c",
    ("../../u v/w.x", Some "\"y z.a\" b.c")

    "\"..\\..\\d e.f\" -g \\\\\"h i\\\\\"",
    ("../../d e.f", Some "-g \\\\\"h i\\\\\"")

    "..\\..\\j k.l -m \\\\\"n o\\\\\"",
    ("../../j", Some "k.l -m \\\\\"n o\\\\\"")
]
|> _assert_fn split_command

#!markdown

### execution_line

#!spiral

type execution_line =
    {
        process_id : int
        line : string
        error : bool
    }

#!markdown

## rust

#!markdown

### process_child

#!spiral

nominal process_child =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Child\")>]\n#endif\ntype std_process_Child = class end"
        $'' : $'std_process_Child'
    )

#!markdown

### process_child_stdin

#!spiral

nominal process_child_stdin =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::ChildStdin\")>]\n#endif\ntype std_process_ChildStdin = class end"
        $'' : $'std_process_ChildStdin'
    )

inl process_child_stdin
    (child : rust.ref (rust.mut' process_child))
    : rust.ref (rust.mut' (optionm'.option' process_child_stdin))
    =
    !\\(child, $'"&mut $0.stdin"')

#!markdown

## runtime

#!markdown

### execution_options

#!spiral

type execution_options =
    {
        command : string
        cancellation_token : optionm'.option' threading.cancellation_token
        environment_variables : array_base (string * string)
        on_line : optionm'.option' (execution_line -> async.async ())
        stdin : optionm'.option' (threading.arc (threading.mutex process_child_stdin) -> ())
        trace : bool
        working_directory : optionm'.option' string
        stderr : bool
    }

inl execution_options (fn : execution_options -> execution_options) : execution_options =
    {
        command = ""
        cancellation_token = None |> optionm'.box
        environment_variables = ;[]
        on_line = None |> optionm'.box
        stdin = None |> optionm'.box
        trace = true
        working_directory = None |> optionm'.box
        stderr = true
    }
    |> fn

#!markdown

## rust

#!markdown

### process_child_stderr

#!spiral

nominal process_child_stderr =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::ChildStderr\")>]\n#endif\ntype std_process_ChildStderr = class end"
        $'' : $'std_process_ChildStderr'
    )

inl process_child_stderr
    (child : rust.ref (rust.mut' process_child))
    : rust.ref (rust.mut' (optionm'.option' process_child_stderr))
    =
    !\\(child, $'"&mut $0.stderr"')

#!markdown

### process_child_stdout

#!spiral

nominal process_child_stdout =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::ChildStdout\")>]\n#endif\ntype std_process_ChildStdout = class end"
        $'' : $'std_process_ChildStdout'
    )

inl process_child_stdout
    (child : rust.ref (rust.mut' process_child))
    : rust.ref (rust.mut' (optionm'.option' process_child_stdout))
    =
    !\\(child, $'"&mut $0.stdout"')

#!markdown

### process_command

#!spiral

nominal process_command =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Command\")>]\n#endif\ntype std_process_Command = class end"
        $'' : $'std_process_Command'
    )

#!markdown

### process_stdio

#!spiral

nominal process_stdio =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Stdio\")>]\n#endif\ntype std_process_Stdio = class end"
        $'' : $'std_process_Stdio'
    )

#!markdown

### process_output

#!spiral

nominal process_output =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::Output\")>]\n#endif\ntype std_process_Output = class end"
        $'' : $'std_process_Output'
    )

#!markdown

### process_exit_status

#!spiral

nominal process_exit_status =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::process::ExitStatus\")>]\n#endif\ntype std_process_ExitStatus = class end"
        $'' : $'std_process_ExitStatus'
    )

#!markdown

### process_output_status

#!spiral

inl process_output_status (output : process_output) : process_exit_status =
    !\\(output, $'"$0.status"')

#!markdown

### process_output_stdout

#!spiral

inl process_output_stdout (output : process_output) : am'.vec u8 =
    !\\(output, $'"$0.stdout"')

#!markdown

### process_output_stderr

#!spiral

inl process_output_stderr (output : process_output) : am'.vec u8 =
    !\\(output, $'"$0.stderr"')

#!markdown

### process_exit_status_code

#!spiral

inl process_exit_status_code (status : process_exit_status) : optionm'.option' i32 =
    !\\(status, $'"$0.code()"')

#!markdown

### stdin_write_all

#!spiral

inl stdin_write_all (stdin : threading.mutex_guard process_child_stdin) (text : string) : () =
    inl stream = text |> sm'.as_bytes
    inl stdin = join stdin
    (!\($'"true; let mut !stdin = !stdin"') : bool) |> ignore
    (!\\(stdin, $'"true; std::io::Write::write_all(&mut *$0, !stream).unwrap()"') : bool) |> ignore

#!markdown

### stdin_flush

#!spiral

inl stdin_flush (stdin : threading.mutex_guard process_child_stdin) : () =
    inl stdin = join stdin
    (!\($'"true; let mut !stdin = !stdin"') : bool) |> ignore
    (!\\(stdin, $'"true; std::io::Write::flush(&mut *$0).unwrap()"') : bool) |> ignore

#!markdown

### new_process_command

#!spiral

inl new_process_command (file_name : string) : process_command =
    !\\(file_name, $'"std::process::Command::new(&*$0)"')

#!markdown

### process_stdio_piped

#!spiral

inl process_stdio_piped () : process_stdio =
    !\($'"std::process::Stdio::piped()"')

#!markdown

### process_command_args

#!spiral

inl process_command_args (args : am'.vec sm'.std_string) (c : process_command) : process_command =
    (!\($'"true; let mut !c = !c"') : bool) |> ignore
    (!\\(args, $'"true; std::process::Command::args(&mut !c, &*$0)"') : bool) |> ignore
    c |> rust.emit

#!markdown

### process_command_stdout

#!spiral

inl process_command_stdout (stdio : process_stdio) (c : process_command) : process_command =
    (!\($'"true; let mut !c = !c"') : bool) |> ignore
    (!\($'"true; std::process::Command::stdout(&mut !c, std::process::Stdio::piped())"') : bool) |> ignore
    c |> rust.emit

#!markdown

### process_command_stderr

#!spiral

inl process_command_stderr (stdio : process_stdio) (c : process_command) : process_command =
    (!\($'"true; let mut !c = !c"') : bool) |> ignore
    (!\($'"true; std::process::Command::stderr(&mut !c, std::process::Stdio::piped())"') : bool) |> ignore
    c |> rust.emit

#!markdown

### process_command_stdin

#!spiral

inl process_command_stdin (stdio : process_stdio) (c : process_command) : process_command =
    (!\($'"true; let mut !c = !c"') : bool) |> ignore
    (!\($'"true; std::process::Command::stdin(&mut !c, std::process::Stdio::piped())"') : bool) |> ignore
    c |> rust.emit

#!markdown

### process_command_current_dir

#!spiral

inl process_command_current_dir (dir : string) (c : process_command) : process_command =
    (!\($'"true; let mut !c = !c"') : bool) |> ignore
    (!\\(dir, $'"true; std::process::Command::current_dir(&mut !c, &*$0)"') : bool) |> ignore
    !\($'$"!c"')

#!markdown

### process_command_env

#!spiral

inl process_command_env (key : string) (value : string) (c : process_command) : process_command =
    (!\($'"true; let mut !c = !c"') : bool) |> ignore
    (!\\((key, value), $'"true; std::process::Command::env(&mut !c, &*$0, &*$1)"') : bool) |> ignore
    c |> rust.emit

#!markdown

### process_command_spawn

#!spiral

inl process_command_spawn
    (c : process_command)
    : resultm.result' process_child stream.io_error
    =
    (!\($'"true; let mut !c = !c"') : bool) |> ignore
    !\($'"std::process::Command::spawn(&mut !c)"')

#!markdown

### child_wait_with_output

#!spiral

inl child_wait_with_output
    (child : process_child)
    : resultm.result' process_output stream.io_error
    =
    !\\(child, $'"$0.wait_with_output()"')

#!markdown

### stdio_line

#!spiral

inl stdio_line
    (stdio : result () ())
    (trace' : bool)
    (channel_sender : threading.arc (threading.mutex (threading.channel_sender sm'.std_string)))
    (line : resultm.result' sm'.std_string stream.io_error)
    : resultm.result' () sm'.std_string
    =
    inl highlight text =
        $'$"\\u001b[4;7m{!text}\\u001b[0m"'
    inl line =
        match
            line
            |> resultm.map_error' sm'.format'
            |> resultm.unbox'
        with
        | Ok line =>
            inl line =
                line
                |> sm'.from_std_string
                // |> sm'.as_bytes
                // |> am'.slice_to_vec
                |> sm'.encoding_encode' (sm'.encoding_utf8' ())
                |> rust.cow_as_ref
                |> sm'.str_from_utf8
                // |> sm'.utf8_decode
                |> resultm.unwrap'
                |> sm'.ref_to_std_string
                // String::from_utf8_lossy(line.as_bytes()).into()
            inl line_log = line |> sm'.from_std_string
            inl text =
                match stdio with
                | Ok () => $'$"> {!line_log}"'
                | Error () => $'$"\! {!line_log}"'
            if trace'
            then trace Verbose (fun () => text) id
            else text |> console.write_line
            match stdio with
            | Ok () => line
            | Error () => line |> highlight |> sm'.to_std_string
        | Error e =>
            trace Critical
                fun () => "runtime.stdio_line"
                fun () => { trace' e }
            e |> highlight |> sm'.to_std_string
    channel_sender
    |> threading.arc_mutex_lock
    |> resultm.unwrap'
    |> threading.mutex_guard_ref
    |> threading.channel_send line
    |> resultm.map_error' sm'.format'

#!markdown

### command

#!spiral

nominal command =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::Command\")>]\n#endif\ntype clap_Command = class end"
        $'' : $'clap_Command'
    )

#!markdown

### new_command

#!spiral

inl new_command (s : rust.static_ref sm'.str) : command =
    !\\(s, $'"clap::Command::new($0)"')

#!spiral

//// test
///! rust -d clap

##"command"
|> new_command
|> sm'.format_pretty
|> _assert sm'.contains "\"command\""

#!markdown

### arg

#!spiral

nominal arg =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::Arg\")>]\n#endif\ntype clap_Arg = class end"
        $'' : $'clap_Arg'
    )

#!markdown

### new_arg

#!spiral

inl new_arg (s : rust.static_ref sm'.str) : arg =
    !\\(s, $'"clap::Arg::new($0)"')

#!spiral

//// test
///! rust -d clap

##"arg"
|> new_arg
|> sm'.format_pretty
|> _assert sm'.contains "\"arg\""

#!markdown

### command_arg

#!spiral

inl command_arg (arg : arg) (command : command) : command =
    !\\((command, arg), $'"clap::Command::arg($0, $1)"')

#!markdown

### arg_required

#!spiral

inl arg_required (value : bool) (arg : arg) : arg =
    !\\((arg, value), $'"$0.required($1)"')

#!markdown

### arg_require_equals

#!spiral

inl arg_require_equals (value : bool) (arg : arg) : arg =
    !\\((arg, value), $'"$0.require_equals($1)"')

#!markdown

### arg_default_value

#!spiral

inl arg_default_value (value : string) (arg : arg) : arg =
    inl value = #value
    !\\((arg, value), $'"$0.default_value($1)"')

#!markdown

### arg_default_missing_value

#!spiral

inl arg_default_missing_value (value : string) (arg : arg) : arg =
    inl value = #value
    !\\((arg, value), $'"$0.default_missing_value($1)"')

#!markdown

### arg_overrides_with

#!spiral

inl arg_overrides_with (value : string) (arg : arg) : arg =
    inl value = #value
    !\\((arg, value), $'"$0.overrides_with($1)"')

#!markdown

### arg_short

#!spiral

inl arg_short (value : char) (arg : arg) : arg =
    !\\((arg, value), $'"$0.short($1)"')

#!markdown

### arg_long

#!spiral

inl arg_long (value : rust.static_ref sm'.str) (arg : arg) : arg =
    !\\((arg, value), $'"$0.long($1)"')

#!markdown

### arg_value_names

#!spiral

inl arg_value_names (values : array_base (rust.static_ref sm'.str)) (arg : arg) : arg =
    inl values = values |> am'.to_vec
    !\\((arg, values), $'"$0.value_names($1)"')

#!markdown

### arg_num_args

#!spiral

inl arg_num_args (value : i32) (arg : arg) : arg =
    !\\((arg, value), $'"$0.num_args($1)"')

#!markdown

### value_range

#!spiral

nominal value_range =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::builder::ValueRange\")>]\n#endif\ntype clap_builder_ValueRange = class end"
        $'' : $'clap_builder_ValueRange'
    )

#!markdown

### new_value_range

#!spiral

inl new_value_range forall t. inclusive (start : _ t) (end : _ t) : value_range =
    inl len () =
        0i32 |> convert
    inl start, end =
        open am'
        match start, end with
        | Start start, End fn =>
            start, len |> fn
        | End start_fn, End end_fn =>
            start_fn len, end_fn len
    inl inclusive =
        if inclusive
        then "="
        else ""
    match start, end with
    | start, end when end =. len () => !\\(start, $'"clap::builder::ValueRange::new($0..)"')
    | start, end => !\\((start, end), $'"clap::builder::ValueRange::new($0.." + !inclusive + "$1)"')

#!markdown

### arg_num_args_range

#!spiral

inl arg_num_args_range (value : value_range) (arg : arg) : arg =
    !\\((arg, value), $'"$0.num_args($1)"')

#!markdown

### arg_value_name

#!spiral

inl arg_value_name (value : string) (arg : arg) : arg =
    inl value = value |> sm'.as_str
    !\\((arg, value), $'"$0.value_name($1)"')

#!markdown

### value_parser

#!spiral

nominal value_parser =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::builder::ValueParser\")>]\n#endif\ntype clap_builder_ValueParser = class end"
        $'' : $'clap_builder_ValueParser'
    )

#!markdown

### possible_value

#!spiral

nominal possible_value =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::builder::PossibleValue\")>]\n#endif\ntype clap_builder_PossibleValue = class end"
        $'' : $'clap_builder_PossibleValue'
    )

#!markdown

### new_possible_value

#!spiral

inl new_possible_value forall t. (x : t) : possible_value =
    !\\(x, $'"clap::builder::PossibleValue::new(&**$0)"')

#!markdown

### value_parser_path_buf

#!spiral

inl value_parser_path_buf () : value_parser =
    !\($'"clap::value_parser\!(std::path::PathBuf)"')

#!markdown

### value_parser_expr

#!spiral

inl value_parser_expr (expr : string) : value_parser =
    !\($'"clap::value_parser\!(" + !expr + ").into()"')

#!markdown

### arg_value_parser

#!spiral

inl arg_value_parser (values : value_parser) (arg : arg) : arg =
    !\\((arg, values), $'"$0.value_parser($1)"')

#!markdown

### arg_action

#!spiral

nominal arg_action' =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::ArgAction\")>]\n#endif\ntype clap_ArgAction = class end"
        $'' : $'clap_ArgAction'
    )

union arg_action =
    | Set
    | Append
    | SetTrue
    | SetFalse
    | Count
    | Help
    | HelpShort
    | HelpLong
    | Version

inl arg_action = function
    | Set => !\($'"clap::ArgAction::Set"') : arg_action'
    | Append => !\($'"clap::ArgAction::Append"') : arg_action'
    | SetTrue => !\($'"clap::ArgAction::SetTrue"') : arg_action'
    | SetFalse => !\($'"clap::ArgAction::SetFalse"') : arg_action'
    | Count => !\($'"clap::ArgAction::Count"') : arg_action'
    | Help => !\($'"clap::ArgAction::Help"') : arg_action'
    | HelpShort => !\($'"clap::ArgAction::HelpShort"') : arg_action'
    | HelpLong => !\($'"clap::ArgAction::HelpLong"') : arg_action'
    | Version => !\($'"clap::ArgAction::Version"') : arg_action'

inl arg_action (value : arg_action) (arg : arg) : arg =
    inl value = value |> arg_action
    !\\((arg, value), $'"$0.action($1)"')

#!markdown

### arg_index

#!spiral

inl arg_index (value : i32) (arg : arg) : arg =
    !\\((arg, value), $'"$0.index($1)"')

#!markdown

### arg_matches

#!spiral

nominal arg_matches =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"clap::ArgMatches\")>]\n#endif\ntype clap_ArgMatches = class end"
        $'' : $'clap_ArgMatches'
    )

#!markdown

### command_get_matches

#!spiral

inl command_get_matches (command : command) : arg_matches =
    !\\(command, $'"clap::Command::get_matches($0)"')

#!markdown

### command_get_matches_from

#!spiral

inl command_get_matches_from (args : array_base string) (command : command) : arg_matches =
    inl args = args |> am'.to_vec |> am'.vec_map sm'.to_std_string
    !\\(command, $'"clap::Command::get_matches_from($0, !args)"')

#!markdown

### command_args_override_self

#!spiral

inl command_args_override_self (yes : bool) (command : command) : command =
    !\\(command, $'"clap::Command::args_override_self($0, !yes)"')

#!markdown

### command_init_arg

#!spiral

inl command_init_arg (long, short) fn command =
    command
    |> command_arg (
        ##long
        |> new_arg
        |> arg_short short
        |> arg_long ##long
        |> fn
    )

#!markdown

### matches_get_one

#!spiral

inl matches_get_one forall t. (x : string) (matches : arg_matches) : optionm'.option' t =
    inl x = join x
    inl x = x |> sm'.as_str
    !\\((matches, x), $'"clap::ArgMatches::get_one(&$0, $1).cloned()"')

#!markdown

### matches_get_flag

#!spiral

inl matches_get_flag (x : string) (matches : arg_matches) : bool =
    inl x = join x
    inl x = x |> sm'.as_str
    !\\((matches, x), $'"clap::ArgMatches::get_flag(&$0, $1)"')

#!markdown

### matches_get_many

#!spiral

inl matches_get_many forall t. (x : string) (matches : arg_matches) : optionm'.option' (am'.vec t) =
    inl x = join x
    inl x = x |> sm'.as_str
    !\\((matches, x), $'"clap::ArgMatches::get_many(&$0, $1).map(|x| x.cloned().into_iter().collect())"')

#!markdown

### matches_get_occurrences

#!spiral

inl matches_get_occurrences (x : string) (matches : arg_matches) : optionm'.option' (array_base sm'.std_string) =
    inl x = join x
    inl x = x |> sm'.as_str
    !\($'"clap::ArgMatches::get_occurrences(&!matches, !x).cloned()"')

#!markdown

### matches_subcommand

#!spiral

inl matches_subcommand (matches : arg_matches) : optionm'.option' (sm'.std_string * arg_matches) =
    !\\((matches, sm'.ref_to_std_string), $'"clap::ArgMatches::subcommand(Box::leak(Box::new($0))).map(|(a, b)| ($1(a), b.clone()))"')

#!markdown

### matches_values_of

#!spiral

inl matches_values_of (x : string) (matches : arg_matches) : array_base sm'.std_string =
    !\\((matches, x), $'"clap::ArgMatches::values_of($0, &*$1)"')

#!markdown

### command_subcommand_required

#!spiral

inl command_subcommand_required (value : bool) (command : command) : command =
    !\\(command, $'"clap::Command::subcommand_required($0, !value)"')

#!markdown

### command_subcommand

#!spiral

inl command_subcommand (subcommand : command) (command : command) : command =
    !\\(command, $'"clap::Command::subcommand($0, !subcommand)"')

#!markdown

### value_parser_possible_values

#!spiral

inl value_parser_possible_values (values : array_base string) : value_parser =
    inl values =
        values
        |> am'.to_vec
        |> am'.vec_map (sm'.to_std_string >> rust.new_box >> rust.box_leak >> new_possible_value)
    !\\(values, $'"Into::<clap::builder::ValueParser>::into(clap::builder::PossibleValuesParser::new($0))"')

#!markdown

### arg_union

#!spiral

inl arg_union forall union_type. (fn : union_type -> ()) (arg : arg) : arg =
    arg
    |> arg_value_parser (
        real reflection.get_union_fields_untag `union_type ()
        |> fun x => x : _ (string * union_type)
        |> listm.map (fst >> sm'.to_lower)
        |> listm'.box
        |> listm'.to_array'
        |> value_parser_possible_values
    )

#!spiral

//// test
///! rust -d clap

##"command"
|> new_command
|> command_init_arg ("trace-level", 't') (
    real arg_union `trace_level ignore
)
|> command_get_matches_from ;[ "_"; "--trace-level"; "critical" ]
|> matches_get_one "trace-level"
|> optionm'.unwrap
|> sm'.from_std_string
|> reflection.union_try_pick
|> optionm.value
|> _assert_eq Critical

#!markdown

### command_debug_assert

#!spiral

inl command_debug_assert (command : command) : () =
    !\\(command, $'"clap::Command::debug_assert($0)"')

#!markdown

## fsharp

#!markdown

### process

#!spiral

nominal process = $'System.Diagnostics.Process'

#!markdown

### process_start_info

#!spiral

nominal process_start_info = $'System.Diagnostics.ProcessStartInfo'

#!markdown

### data_received_event_args

#!spiral

nominal data_received_event_args = $'System.Diagnostics.DataReceivedEventArgs'

#!markdown

### new_process

#!spiral

inl new_process (process_start_info : process_start_info) : process =
    $'new `process (StartInfo = !process_start_info)'

#!markdown

### process_start

#!spiral

inl process_start (process : process) : bool =
    $'!process.Start' ()

#!markdown

### process_exit_code

#!spiral

inl process_exit_code (process : process) : i32 =
    run_target function
        | Fsharp (Native) => fun () => $'!process.ExitCode'
        | _ => fun () => null ()

#!markdown

### process_id

#!spiral

let process_id (process : process) : i32 =
    run_target function
        | Fsharp (Native) => fun () => process |> $'_.Id'
        | _ => fun () => null ()

#!markdown

### process_has_exited

#!spiral

let process_has_exited (process : process) : bool =
    run_target function
        | Fsharp (Native) => fun () => process |> $'_.HasExited'
        | _ => fun () => null ()

#!markdown

### process_kill

#!spiral

let process_kill (process : process) : () =
    run_target function
        | Fsharp (Native) => fun () => process |> $'_.Kill()'
        | _ => fun () => ()

#!markdown

### process_begin_error_read_line

#!spiral

inl process_begin_error_read_line (process : process) : () =
    process |> $'_.BeginErrorReadLine()'

#!markdown

### process_begin_output_read_line

#!spiral

inl process_begin_output_read_line (process : process) : () =
    process |> $'_.BeginOutputReadLine()'

#!markdown

### process_add_output_data_received

#!spiral

inl process_add_output_data_received fn (process : process) : () =
    $'!process.OutputDataReceived.Add !fn '

#!markdown

### process_add_error_data_received

#!spiral

inl process_add_error_data_received fn (process : process) : () =
    $'!process.ErrorDataReceived.Add !fn '

#!markdown

### process_wait_for_exit_async

#!spiral

inl process_wait_for_exit_async (ct : threading.cancellation_token) (process : process) : async.task () =
    run_target function
        | Fsharp (Native) => fun () => $'!process.WaitForExitAsync !ct '
        | _ => fun () => null ()

#!markdown

### event_data

#!spiral

let event_data (e : data_received_event_args) : string =
    run_target function
        | Fsharp (Native) => fun () => e |> $'_.Data'
        | _ => fun () => null ()

#!markdown

### current_process_kill

#!spiral

let current_process_kill () =
    run_target function
        | Fsharp (Native) => fun () =>
            inl fn () =
                run_target function
                    | Fsharp (Native) => fun () =>
                        trace Warning (fun () => "runtime.current_process_kill / exiting... 3") id
                        $'System.Threading.Thread.Sleep 500'
                        trace Warning (fun () => "runtime.current_process_kill / exiting... 2") id
                        $'System.Console.Out.Flush ()'
                        $'System.Threading.Thread.Sleep 1000'
                        trace Warning (fun () => "runtime.current_process_kill / exiting... 1") id
                        $'System.Diagnostics.Process.GetCurrentProcess().Kill ()' : ()
                    | _ => fun () => ()
            inl thread : threading.thread = $'new System.Threading.Thread (!fn)'
            thread |> $'_.Start()' : ()
        | _ => fun () => ()

#!markdown

### gc_collect

#!spiral

inl gc_collect () =
    run_target function
        | Fsharp _ => fun () => $'System.GC.Collect' () : ()
        | Python _ => fun () =>
            backend_switch {
                Python = fun () => global "import gc"
            }
            ($'gc.collect()' : int) |> ignore
        | _ => fun () => ()

#!markdown

## runtime

#!markdown

### execute_with_options

#!spiral

let execute_with_options (options : execution_options) : i32 * string =
    inl command = join options.command
    inl file_name, arguments = command |> split_command |> resultm.get
    inl arguments =
        arguments
        |> optionm'.default_value ""
        |> split_args
        |> resultm.get
        |> am'.to_vec
        |> am'.vec_map sm'.to_std_string
    trace Debug
        fun () => "runtime.execute_with_options"
        fun () => { file_name arguments = arguments |> sm'.format_debug; options }
    fun () =>
        fun () =>
            // inl new_command_mutex (command : rust.ref (rust.mut' process_command)) : threading.arc (threading.mutex process_command) =
                // ()
            file_name
            |> new_process_command
            |> process_command_args arguments
            |> process_command_stdout (process_stdio_piped ())
            |> process_command_stderr (process_stdio_piped ())
            |> process_command_stdin (process_stdio_piped ())
            // |> new_command_mutex
            |> fun command =>
                match options.working_directory |> optionm'.unbox with
                | Some working_directory => command |> process_command_current_dir working_directory
                | None => !\($'$"!command"') |> rust.emit
            |> fun command =>
                match options.environment_variables with
                | ;[] => command
                | vars =>
                    (command, vars |> am'.to_vec)
                    ||> am'.vec_fold' fun command (key, value) =>
                        command |> process_command_env key value
            |> process_command_spawn
            |> resultm.map_error' sm'.format'
            |> resultm.map' (optionm'.some' >> (join id) >> threading.new_arc_mutex)
            |> resultm.unbox'
            |> function
                | Ok child =>
                    inl stdout =
                        fun () =>
                            child
                            |> threading.arc_mutex_lock
                            |> resultm.unwrap'
                            |> threading.mutex_guard_ref_mut
                            |> optionm'.as_mut
                            |> optionm'.unwrap
                            |> process_child_stdout
                            |> optionm'.take_ref_mut
                            |> optionm'.unwrap
                        |> rust.capture
                    inl stderr =
                        fun () =>
                            child
                            |> threading.arc_mutex_lock
                            |> resultm.unwrap'
                            |> threading.mutex_guard_ref_mut
                            |> optionm'.as_mut
                            |> optionm'.unwrap
                            |> process_child_stderr
                            |> optionm'.take_ref_mut
                            |> optionm'.unwrap
                        |> rust.capture
                    inl stdin =
                        fun () =>
                            child
                            |> threading.arc_mutex_lock
                            |> resultm.unwrap'
                            |> threading.mutex_guard_ref_mut
                            |> optionm'.as_mut
                            |> optionm'.unwrap
                            |> process_child_stdin
                            |> optionm'.take_ref_mut
                            |> optionm'.unwrap
                            |> optionm'.some'
                            |> join id
                            |> threading.new_arc_mutex
                        |> rust.capture
                    inl channel_sender, channel_receiver = threading.new_channel ()
                    inl channel_sender'' = channel_sender |> (join id) |> threading.new_arc_mutex
                    inl channel_sender' = channel_sender |> (join id) |> threading.new_arc_mutex
                    inl channel_receiver' = channel_receiver |> (join id) |> threading.new_arc_mutex
                    inl stdout_handle =
                        fun () =>
                            stdout
                            |> stream.decode_reader_bytes_build
                            |> stream.new_buf_reader
                            |> stream.buf_read_lines
                            |> iter.try_for_each fun lines =>
                                inl channel_sender'' = channel_sender'' |> rust.clone
                                lines
                                |> stdio_line (Ok ()) options.trace channel_sender''
                                |> resultm.to_try
                        |> threading.spawn (1, 0) 1
                    inl stderr_handle =
                        fun () =>
                            stderr
                            |> stream.decode_reader_bytes_build
                            |> stream.new_buf_reader
                            |> stream.buf_read_lines
                            |> iter.try_for_each fun lines =>
                                if options.stderr |> not
                                then Ok () |> resultm.box
                                else
                                    inl channel_sender' = channel_sender' |> rust.clone
                                    lines
                                    |> stdio_line (Error ()) options.trace channel_sender'
                                |> resultm.to_try
                        |> threading.spawn (1, 0) 1
                    match options.stdin |> optionm'.unbox with
                    | Some stdin' =>
                        stdin
                        |> threading.arc_mutex_lock
                        |> resultm.unwrap'
                        |> threading.mutex_guard_ref_mut
                        |> optionm'.take_ref_mut
                        |> optionm'.map' threading.new_arc_mutex
                        |> optionm'.unbox
                        |> function
                            | Some stdin =>
                                stdin |> stdin'
                                stdin
                                |> threading.arc_mutex_lock
                                |> resultm.unwrap'
                                |> stdin_flush
                            | None => ()
                    | None => ()
                    inl output =
                        child
                        |> threading.arc_mutex_lock
                        |> resultm.unwrap'
                        |> threading.mutex_guard_ref_mut
                        |> optionm'.take_ref_mut
                        |> optionm'.unwrap
                        |> child_wait_with_output
                        |> resultm.map_error' sm'.format'
                    [ stdout_handle; stderr_handle ]
                    |> am'.new_vec
                    |> am'.vec_for_each' (threading.join' >> resultm.unwrap' >> resultm.unwrap')
                    match output |> resultm.unbox with
                    | Ok output =>
                        inl exit_code =
                            output
                            |> process_output_status
                            |> process_exit_status_code
                            |> optionm'.unbox
                        match exit_code with
                        | Some exit_code =>
                            inl stdout =
                                output
                                |> process_output_stdout
                                |> sm'.string_from_utf8
                                |> resultm.unwrap'
                            inl stderr =
                                output
                                |> process_output_stderr
                                |> sm'.string_from_utf8
                                |> resultm.unwrap'
                            inl output =
                                [ stdout; stderr ]
                                |> listm.map (sm'.from_std_string >> sm'.trim)
                                |> listm'.filter (sm'.is_empty >> not)
                                |> sm'.concat_list "\n"
                                |> sm'.to_std_string
                                |> Some
                            exit_code, output, Some channel_receiver'
                        | None =>
                            -1,
                            ("runtime.execute_with_options / exit_code=None"
                                |> sm'.to_std_string
                                |> Some),
                            Some channel_receiver'
                    | Error error =>
                        trace Critical
                            fun () => "runtime.execute_with_options / output error"
                            fun () => {
                                error file_name arguments = arguments |> sm'.format_debug; options
                            }
                        -2i32, error |> Some, None
                | Error error =>
                    trace Critical
                        fun () => "runtime.execute_with_options / child error"
                        fun () => {
                            error file_name arguments = arguments |> sm'.format_debug; options
                        }
                    -1i32, error |> Some, None
            |> function
                | exit_code, std_trace, channel_receiver =>
                    inl std_trace =
                        channel_receiver
                        |> optionm'.box
                        |> optionm'.map' fun channel_receiver =>
                            channel_receiver
                            |> threading.arc_mutex_lock
                            |> resultm.unwrap'
                            |> iter.iter
                            |> iter_collect''
                            |> am'.vec_map sm'.from_std_string
                            |> am'.from_vec
                            |> fun x => x : _ i32 _
                            |> seq.of_array
                            |> sm'.concat "\n"
                        |> optionm'.unbox
                        |> optionm.map (sm'.trim >> sm'.to_option)
                        |> optionm'.flatten
                        |> optionm'.default_value (
                            std_trace
                            |> optionm.map sm'.from_std_string
                            |> optionm'.default_value ""
                        )
                    trace Verbose
                        fun () => "runtime.execute_with_options / result"
                        fun () => {
                            file_name exit_code std_trace_length = std_trace |> sm'.length : i32
                        }
                    new_pair exit_code std_trace
        |> capture
    // |> async.new_future_move
    // |> async.block_on
    |> fun x => x ()
    |> from_pair

#!markdown

#### execute

#!spiral

let execute command =
    execution_options fun x => { x with
        command = command
    }
    |> execute_with_options

#!markdown

#### tests

#!spiral

//// test
///! rust -d chrono encoding_rs encoding_rs_io regex sha2

inl content = "╭─[ 你好，世界！こんにちは世界！ ]─╮"

inl file_name = join "test.txt"
inl temp_dir, disposable =
    (file_name, content)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
disposable |> use |> ignore
inl path = temp_dir </> file_name |> file_system.normalize_path
inl exit_code, result =
    execute $'\@$"pwsh -c ""[IO.File]::ReadAllText(\'{!path}\')"""'
exit_code |> _assert_eq 1
result |> _assert sm'.contains "not find file"

content |> file_system.write_all_text path

inl exit_code, output =
    execution_options fun x => { x with
        command = $'\@$"pwsh -c ""[System.Console]::OutputEncoding = [System.Text.Encoding]::UTF8; [IO.File]::ReadAllText(\'{!file_name}\')"""'
        working_directory = Some temp_dir |> optionm'.box
    }
    |> execute_with_options

exit_code |> _assert_eq 0i32
output |> _assert_eq content

#!spiral

//// test
///! rust -d chrono encoding_rs encoding_rs_io regex sha2

/// task: write a script to test the real time capabilities of std capturing

inl exit_code, output =
    execution_options fun x => { x with
        command = $'\@$"pwsh -c ""[System.Console]::OutputEncoding = [System.Text.Encoding]::UTF8; for ($i = 0; $i -lt 5; $i++) {{ Write-Output ``""Line$i``""; Start-Sleep -Milliseconds 200 }}"""'
        // trace = true
    }
    |> execute_with_options
exit_code |> _assert_eq 0i32
output |> _assert sm'.contains "Line4"

#!markdown

### execute_retry

#!spiral

let execute_retry retries options =
    fun () =>
        inl exit_code, result = options |> execute_with_options
        if exit_code = 0
        then Ok (exit_code, result)
        else Error (exit_code, result)
    |> retry_fn' retries

#!markdown

## main

#!spiral

inl main () =
    init_trace_state None
    $'let current_process_kill () = !current_process_kill ()' : ()
    inl execution_options fn =
        execution_options fun x =>
            x
            |> heap
            |> fn
            |> fun x => !x
    $'let execution_options x = !execution_options x' : ()
    inl split_args x = x |> split_args |> resultm.box
    $'let split_args x = !split_args x' : ()
