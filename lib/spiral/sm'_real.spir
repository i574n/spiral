/// # sm'

/// ## rust

/// ### std_string_real
///- --real

nominal std_string_real =
    `(
        backend_switch `(()) `({}) {
            Fsharp =
                (fun () =>
                    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::string::String\")>]\ntype std_string_String = class end\n\#else\ntype std_string_String = string\n#endif\n"
                ) : () -> ()
        }
        $'' : $'std_string_String'
    )

/// ### std_string

/// ### to_string'

/// ### from_std_string_real
///- --real

inl from_std_string_real (str : std_string_real) : string =
    open rust
    rust.emit_expr `std_string_real `string str ($'"fable_library_rust::String_::fromString($0)"' : string)

/// ### from_std_string

/// ## sm'

/// ### symbol_to_string_real
///- --real

inl symbol_to_string_real forall t {symbol}. : string =
    // inl x = real_core.type_lit_to_lit `t
    // inl x = real_core.type_to_symbol `t
    // inl x = real_core.type_lit_to_lit `t
    // !!!!SymbolToString (`(`t))
    inl x = real_core.type_to_symbol `t
    !!!!SymbolToString (x)

/// ### symbol_to_string

/// ### index

/// ### length

/// ### (~##)

/// ### to_char_list

/// ### to_char_array

/// ### is_empty

/// ### to_option

/// ### string_builder_real
///- --real

nominal string_builder_python =
    `(
        global "import io"
        $'' : $'io.StringIO'
    )
type string_builder_switch =
    {
        Gleam : string
        Fsharp : $'System.Text.StringBuilder'
        Python : string_builder_python
    }
nominal string_builder_real = $'backend_switch `(string_builder_switch)'

/// ### string_builder

/// ### append_real
///- --real

inl append_real (x : string) (s : string) : string =
    backend_switch `string `({}) {
        Gleam = (fun () => $'!s <> !x ' : string) : () -> string
        Lua = (fun () => $'!s .. !x ' : string) : () -> string
        Fsharp = (fun () => (+.) `string s x) : () -> string
        Python = (fun () => (+.) `string s x) : () -> string
    }

/// ### append

/// ### (++#*)
///- --real

inl (++#*) (a : string) (b : string) : string =
    append_real b a

/// ### (++#)

/// ### (++\\\\#)

/// ### (++\\#)

/// ### format_debug_real
///- --real

inl rec format_debug_real forall t. (x : t) : string =
    typecase t with
    | string => x
    | _ =>
        backend_switch `string `({}) {
            Gleam =
                (fun () =>
                    typecase t with
                    | char => convert.to `(`x) `string x
                    | string_builder_real => convert.to `(`x) `string x
                    | _ =>
                        global "import gleam/string"
                        inl x =
                            typecase t with
                            | array_base _ => $'!x |> array.to_list' : t
                            | _ => x
                        $'string.inspect(!x)' : string
                    ) : () -> string
            Lua =
                (fun () =>
                    typecase t with
                    | ~a * ~b =>
                        inl a, b =
                            if not (var_is `t x)
                            then x
                            else ($'__v[1]._1' : a), ($'__v[1]._2' : b)
                        inl head_str = format_debug_real `a a
                        inl tail_str = format_debug_real `b b
                        (++#*) head_str ((++#*) ", " tail_str)
                    | {} => $'table.concat(!x, ", ")   ' : string
                    | array_base _ =>
                        (++#*) ((++#*) "[" ($'table.concat(!x, ", ")' : string)) "]"
                    | t =>
                        if real_core.union_type_is `t
                        then serialize_union `t x
                        else $'tostring(!x)       ' : string
                ) : () -> string
            Fsharp = (fun () => $'$"%A{!x}"' : string) : () -> string
            Python =
                (fun () =>
                    $'f"{!x}"' : string
                ) : () -> string
        }
and inl serialize_union forall t. (x : t) : string =
    join
        $'if type(v0) ~= "table" then return tostring(v0) end' : ()
        real_core.unbox x fun k, v =>
            inl tag : string = $'__v[1].tag'
            typecase `v with
            | () => tag
            | ~a * ~b =>
                typecase a with
                | ~c * ~d =>
                    inl head_str = format_debug_real `c ($'__v[1]._1 ' : c)
                    inl tail_str = format_debug_real `d ($'__v[1]._2  ' : d)
                    inl x = format_debug_real `b ($'__v[1]._3   ' : b)
                    tag ++#* "(" ++#* head_str ++#* ", " ++#* tail_str ++#* ", " ++#* x ++#* ")"
                | _ =>
                    inl head_str = format_debug_real `a ($'__v[1]._1    ' : a)
                    inl tail_str = format_debug_real `b ($'__v[1]._2     ' : b)
                    (++#*) tag ((++#*) "(" ((++#*) head_str ((++#*) ", " ((++#*) tail_str ")"))))
            | ~a =>
                inl arg_str = format_debug_real `a ($'__v[1]._1' : a)
                (++#*) tag ((++#*) "(" ((++#*) arg_str ")"))
    : string

/// ### format_debug

/// ### (~#?*)

/// ### unwrap_format

/// ### obj_to_string

/// ### (~#?**)

/// ### concat_list

/// ### slice

/// ### format_pretty_real
///- --real

inl format_pretty_real forall t. (x : t) : string =
    run_target_args `string `t (fun () => x) function
        | Rust _ => fun x =>
            open rust
            inl result = rust.emit_expr `t `std_string_real x ($'"format\!(\\\"{:\#?}\\\", $0)"' : string)
            from_std_string_real result
        | _ => fun _ => format_debug_real `t x

/// ### format_pretty

/// ### prim

/// ### printable
///- --real

prototype printable t : t -> ()

/// ### format_real
///- --real

let format_real forall t. (x : t) : string =
    inl empty : string =
        backend_switch `string `({}) {
            Gleam =
                (fun () =>
                    ""
                ) : () -> string
            Lua =
                (fun () =>
                    ""
                ) : () -> string
            Fsharp =
                (fun () =>
                    join ""
                ) : () -> string
            Python =
                (fun () =>
                    ""
                ) : () -> string
        }
    inl result = mut `string empty
    inl rec write x =
        inl p ((a : string), b) =
            inl s : string =
                backend_switch `string `({}) {
                    Gleam =
                        (fun () =>
                            match b with
                            | (_ : string) => b : string
                            // | (_ : f32) | (_ : f64) => format_debug `(`b) b
                            | _ => format_debug_real `(`b) b
                        ) : () -> string
                    Lua =
                        (fun () =>
                            match b with
                            | (_ : string) => b : string
                            // | (_ : f32) | (_ : f64) => format_debug `(`b) b
                            | _ => format_debug_real `(`b) b
                        ) : () -> string
                    Fsharp =
                        (fun () =>
                            match b with
                            | (_ : f32) | (_ : f64) => $'$"%+.6f{!b}"' : string
                            | (_ : string) => b : string
                            | _ => $'$"{!b}"' : string
                        ) : () -> string
                    Python =
                        (fun () =>
                            match b with
                            | (_ : f32) | (_ : f64) => $'"{:.6f}".format(!b)' : string
                            | (_ : string) => b : string
                            | _ => $'f"{!b}"' : string
                        ) : () -> string
                }
            backend_switch `(()) `({}) {
                Gleam =
                    (fun () =>
                        exec_unit ((fun () => result <- append_real s ((~*) `string result)) : () -> ())
                    ) : () -> ()
                Lua =
                    (fun () =>
                        exec_unit ((fun () => result <- append_real s ((~*) `string result)) : () -> ())
                    ) : () -> ()
                Fsharp =
                    (fun () =>
                        join
                            result <- append_real s ((~*) `string result)
                    ) : () -> ()
                Python =
                    (fun () =>
                        join
                            result <- append_real s ((~*) `string result)
                    ) : () -> ()
            }

        match x with // According to Bing it shouldn't matter whether these are %d or %lld in printf.
        | () => ()
        | (x : i8) | (x : i16) | (x : i32) | (x : i64) => p ("%d", x)
        | (x : u8) | (x : u16) | (x : u32) | (x : u64) => p ("%u", x)
        | (x : f32) | (x : f64) => p ("%f", x)
        | (x : string) => p ("%s", x)
        | (x : char) => p ("%c", x)
        | (x : bool) => p ("%s", if x then "true" else "false")
        | (a,b) => write a . write ", " . write b
        | {} as x =>
            write "{ "
            inl _result =
                real_core.record_fold
                    fun { state = separator key value } =>
                        write separator
                        write (symbol_to_string_real `(`key)) . write " = " . write value
                        "; "
                    () x
            write " }"
        | x when real_core.symbol_is x => write (symbol_to_string_real `(`x))
        | x when real_core.function_is x => write (x ())
        | x when real_core.union_is x =>
            if real_core.prototype_has `(`x) printable then printable `(`x) x
            else
                inl temp () =
                    real_core.unbox x (fun (k, v) =>
                        write k
                        match v with
                        | () => ()
                        | _ => (join write "(" . write v . write ")") : ()
                        )
                write (format_debug_real `(`x) x)
        | x when real_core.nominal_is x =>
            if real_core.prototype_has `(`x) printable then printable `(`x) x
            // elif layout_is x then write *x // TODO: Deal with all the layout type cases.
            else write (format_pretty_real `(`x) x)
        | x => write (format_debug_real `(`x) x)
    write x
    (~*) `string result

/// ### format

/// ### (~#?)

/// ### (++#?)

/// ### to_char_array

/// ### concat_array

/// ### ellipsis

/// ## fsharp

/// ### last_index_of

/// ### index_of_char

/// ### index_of_char_from

/// ### index_of

/// ### replicate

/// ### pad_left

/// ### pad_right

/// ### convert_to_utf32

/// ### ends_with

/// ### starts_with

/// ### is_white_space

/// ### substring

/// ### to_lower

/// ### to_upper

/// ### char_to_upper

/// ### builder_append

/// ### builder_append_line

/// ### builder_replace

/// ### builder_clear

/// ### builder_insert

/// ### span_from

/// ### char_contains

/// ### trim_chars

/// ### trim_start

/// ### trim_end

/// ### trim_with

/// ### trim

/// ### concat

/// ### length'

/// ### to_string any

/// ### replace

/// ### split

/// ### split_string

/// ### join'

/// ### encoding

/// ### encoding_utf8

/// ### utf8_get_bytes

/// ### byte_to_string

/// ## rust

/// ### str

/// ### chars

/// ### char_is_alphanumeric

/// ### byte_slice

/// ### display

/// ### base64_decode_error

/// ### borsh_io_error

/// ### utf8_error

/// ### from_utf8_error

/// ### json_value

/// ### json_error

/// ### serde_wasm_bindgen_error

/// ### js_string

/// ### os_str

/// ### c_str

/// ### c_string

/// ### os_string

/// ### raw_string_literal

/// ### raw_string_literal_static

/// ### (~#)

/// ### (~###)

/// ### include_str

/// ### as_str

/// ### from_iter

/// ### ref_to_std_string

/// ### cow_to_std_string

/// ### to_std_string

/// ### as_str_std

/// ### into_boxed_str

/// ### os_string_as_ref

/// ### to_os_string

/// ### new_c_string

/// ### os_to_str

/// ### from_os_str_ref

/// ### format_custom'

/// ### format_debug'

/// ### format'

/// ### format_hex'

/// ### format''

/// ### regex

/// ### regex_error

/// ### new_regex

/// ### captures

/// ### regex_capture_matches

/// ### regex_capture_names

/// ### match'

/// ### regex_captures_iter

/// ### regex_captures

/// ### serialize

/// ### deserialize

/// ### borsh_serialize

/// ### borsh_deserialize

/// ### deserialize_vec

/// ### encode_uri_component

/// ### strip_prefix

/// ### str_from_utf8

/// ### string_from_utf8

/// ### base64_decode

/// ### encoding'

/// ### encoding_utf8'

/// ### encoding_1252

/// ### encoding_encode

/// ### utf8_decode

/// ### windows

/// ### any

/// ### slice_contains

/// ### as_bytes

/// ### into_bytes

/// ## python

/// ### encode_utf8

/// ## sm'

/// ### contains

/// ### to_string result t u

/// ### format_exception

/// ### range

/// ### ellipsis_end

/// ### format_ellipsis

/// ### replace_regex

/// ## main

/// ## rust
